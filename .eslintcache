[{"/home/xera/web-projects/LOLCODE_Project/src/index.js":"1","/home/xera/web-projects/LOLCODE_Project/src/utils/semantics.js":"2","/home/xera/web-projects/LOLCODE_Project/src/utils/lexemes.js":"3","/home/xera/web-projects/LOLCODE_Project/src/utils/parser.js":"4","/home/xera/web-projects/LOLCODE_Project/src/reportWebVitals.js":"5","/home/xera/web-projects/LOLCODE_Project/src/main/App.js":"6","/home/xera/web-projects/LOLCODE_Project/src/page/AppRouter.js":"7","/home/xera/web-projects/LOLCODE_Project/src/page/index.js":"8","/home/xera/web-projects/LOLCODE_Project/src/page/TitlePage.js":"9","/home/xera/web-projects/LOLCODE_Project/src/page/Interpreter.js":"10","/home/xera/web-projects/LOLCODE_Project/src/components/index.js":"11","/home/xera/web-projects/LOLCODE_Project/src/components/firstFrame.js":"12","/home/xera/web-projects/LOLCODE_Project/src/components/secondFrame.js":"13","/home/xera/web-projects/LOLCODE_Project/src/components/fourthFrame.js":"14","/home/xera/web-projects/LOLCODE_Project/src/components/thirdFrame.js":"15","/home/xera/web-projects/LOLCODE_Project/src/components/fifthFrame.js":"16"},{"size":505,"mtime":1609414692480,"results":"17","hashOfConfig":"18"},{"size":40967,"mtime":1609415258080,"results":"19","hashOfConfig":"18"},{"size":3820,"mtime":1609415153960,"results":"20","hashOfConfig":"18"},{"size":73685,"mtime":1609415130960,"results":"21","hashOfConfig":"18"},{"size":362,"mtime":1609384707470,"results":"22","hashOfConfig":"18"},{"size":211,"mtime":1609414692480,"results":"23","hashOfConfig":"18"},{"size":485,"mtime":1609414692480,"results":"24","hashOfConfig":"18"},{"size":59,"mtime":1609414692480,"results":"25","hashOfConfig":"18"},{"size":1380,"mtime":1609414692480,"results":"26","hashOfConfig":"18"},{"size":1412,"mtime":1609414692480,"results":"27","hashOfConfig":"18"},{"size":151,"mtime":1609414692480,"results":"28","hashOfConfig":"18"},{"size":1629,"mtime":1609414692480,"results":"29","hashOfConfig":"18"},{"size":1416,"mtime":1609417781950,"results":"30","hashOfConfig":"18"},{"size":314,"mtime":1609414692480,"results":"31","hashOfConfig":"18"},{"size":1069,"mtime":1609417795930,"results":"32","hashOfConfig":"18"},{"size":1766,"mtime":1609414692480,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"mwyusg",{"filePath":"37","messages":"38","errorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"36"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"36"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62","usedDeprecatedRules":"36"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"36"},"/home/xera/web-projects/LOLCODE_Project/src/index.js",[],["72","73"],"/home/xera/web-projects/LOLCODE_Project/src/utils/semantics.js",["74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98"],"import { literal } from './lexemes';\n// javascript has to float, they use number instead of\n// integers and float\n\n// a function that removes the comments and\n// comment keyword identifiers in the symbol table\nexport const removeComments = (symbol_table) =>\n{\n\tfor (var i = 0; i<symbol_table.length; i++)\n\t{\n\t\tswitch (symbol_table[i].description)\n\t\t{\n\t\t\tcase 'Comment': \n\t\t\tcase 'Line Comment Keyword':\n\t\t\tcase 'Comment Delimiter Keyword':\n\t\t\t\tsymbol_table.splice(i,1);\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// a function that recursively executes the line until it reaches a new line,\n// enough operands is met, or MKAY is encountered\nconst recursive_operations = (code,symbol_table, lexicon, func_table, line_number,handlePrefixChanges) => \n{\n\tlet cur_code = symbol_table.shift(); // gets the first element in the symbol table\n\tlet value; // variable for storing value of operand\n\tlet operands = [];// list of operands\n\tlet type; // variable for storing the data type of the operand\n\tlet req_ops = 2; // variable for checking the number of operands required, default is 2\n\tlet to_break = false; // variable for checking if MKAY is encountered\n\tconst req_op_1 = [\"NOT\", \"ITZ\", \"MEBBE\", \"R\", \"OMG\", \"FOUND\"];\n\tconst no_req = [\"ALL OF\", \"ANY OF\", \"SMOOSH\", \"I IZ\"];\n\tconst literals = [\"NUMBR Literal\", \"NUMBAR Literal\", \"YARN Literal\", \"TROOF Literal\"];\n\tlet error;\n\tif(literals.indexOf(code.description) > -1)\n\t{\n\t\ttype = code.description.split(\" \")[0];\n\t\tif(type === \"NUMBAR\" || type === \"NUMBR\") value = Number(code.value);\n\t\telse if (type === \"YARN\") value = code.value.slice(1,-1);\n\t\telse value = code.value;\n\t\treturn [value, type];\n\t}\n\telse if(code.value === \"NOOB\") return [undefined, \"NOOB\"];\n \telse if (req_op_1.indexOf(code.value) > -1) req_ops = 1; // not requires only 1 operand\n\telse if (no_req.indexOf(code.value) > -1) req_ops = -1; // infinite operands\n\n\twhile(cur_code.value !== \"\\n\" && cur_code.value !== \",\")\n\t{\n\t\tswitch(cur_code.description)\n\t\t{\n\t\t\tcase \"NUMBR Literal\": operands.push({value:Number(cur_code.value), type:\"NUMBR\", name:\"Literal\"});\n\t\t\t\tbreak;\n\t\t\tcase \"NUMBAR Literal\": operands.push({value:Number(cur_code.value), type:\"NUMBAR\", name: \"Literal\"});\n\t\t\t\tbreak;\n\t\t\tcase \"YARN Literal\": operands.push({value:cur_code.value.slice(1,-1), type:\"YARN\", name: \"Literal\"});\n\t\t\t\tbreak;\n\t\t\tcase \"TROOF Literal\": operands.push({value:cur_code.value, type:\"TROOF\", name: \"Literal\"});\n\t\t\t\tbreak;\n\t\t\tcase \"Type Keyword\": cur_code = symbol_table.shift();\n\t\t\t\toperands.push({value:undefined, type:cur_code.value, name:\"Type\"});\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\": \n\t\t\t\tif(cur_code.value === \"NOOB\")\n\t\t\t\t{\n\t\t\t\t\toperands.push({value:undefined, type:\"NOOB\"})\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet i;\n\t\t\t\tfor (i=0; i<lexicon.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif(lexicon[i].name === cur_code.value)\n\t\t\t\t\t{\n\t\t\t\t\t\toperands.push({value:lexicon[i].value, type:lexicon[i].type,name:lexicon[i].name});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (i === lexicon.length) return `Error in line ${line_number}: variable ${cur_code.value} is undeclared`;\n\t\t\t\tbreak;\n\t\t\tcase 'Function Identifier': operands.push(cur_code.value);\n\t\t\t\tbreak;\n\t\t\tcase \"Infinite Delimiter Keyword\": to_break = true;\n\t\t\tcase \"Parameter Delimiter Keyword\":\n\t\t\tcase \"Operand Delimiter Keyword\": break;\n\t\t\tdefault:\n\t\t\t\terror = recursive_operations(cur_code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[value, type] = error;\n\t\t\t\toperands.push({value:value, type:type});\n\t\t}\n\t\tif (req_ops === operands.length || to_break) break;\n\t\tcur_code = symbol_table.shift();\n\t}\n\n\tif(cur_code.value === \"\\n\") symbol_table.unshift(cur_code);\n\n\tif(req_ops === operands.length || to_break)\n\t{\n\t\tconst arith = [\"SUM OF\", \"DIFF OF\", \"PRODUKT OF\", \"QUOSHUNT OF\", \"MOD OF\", \"BIGGR OF\", \"SMALLR OF\"];\n\t\tconst bool = [\"BOTH OF\", \"EITHER OF\", \"WON OF\", \"NOT\", \"ALL OF\", \"ANY OF\"];\n\t\tconst comparison = [\"BOTH SAEM\", \"DIFFRINT\"];\n\n\t\tif(arith.indexOf(code.value) >-1) return arithmetic_operations(code.value,operands,line_number);\n\t\telse if (bool.indexOf(code.value) > -1) return boolean_operations(code.value,operands, line_number);\n\t\telse if (comparison.indexOf(code.value) > -1) return comparison_operations(code.value,operands, line_number);\n\t\telse if (code.value === \"MAEK\") {if(operands[0].type !== operands[1].type) return typecast(operands[0], operands[1].type,line_number);}\n\t\telse if (code.value === \"I IZ\") return eval_function(operands, lexicon, func_table, line_number,handlePrefixChanges)\n\t\telse if (code.value === \"SMOOSH\") return SMOOSH(operands, line_number);\n\t\treturn [operands[0].value, operands[0].type];\n\t}\n\telse if (code.value === \"SMOOSH\") return SMOOSH(operands, line_number);\n\telse if(operands.length < req_ops) return `Error in line ${line_number}: function ${code.value} requires ${req_ops} operands, only received ${operands.length} operands`;\n\telse return `Error in line ${line_number}: ${code.value} expecting MKAY keyword at the end`;\n}\n\nconst arithmetic_operations = (code, operands, line_number) =>\n{\n\tlet i = 0;\n\tfor (i; i<2; i++)\n\t{\n\t\tif (operands[i].type === \"NOOB\") return `Error in line ${line_number}: NOOB value cannot by implicitly typecasted into a NUMBR/NUMBAR`;\n\t\telse if (operands[i].type !== \"NOOB\" && operands[i].value === undefined) return `Error in line ${line_number}: variable ${operands[i].name} is uninitialized before use`;\n\t\telse if (operands[i].type === \"TROOF\")\n\t\t{\n\t\t\toperands[i].value = (operands[i].value === \"WIN\")? 1: 0;\n\t\t\toperands[i].type = \"NUMBR\";\n\t\t}\n\t\telse if (operands[i].type === \"YARN\")\n\t\t{\n\t\t\tconst check = operands[i].value;\n\t\t\tif (literal['NUMBAR'][0].test(check))\n\t\t\t{\n\t\t\t\toperands[i].value = Number(check);\n\t\t\t\toperands[i].type = \"NUMBAR\";\n\t\t\t}\n\t\t\telse if (literal['NUMBR'][0].test(check))\n\t\t\t{\n\t\t\t\toperands[i].value = Number(check);\n\t\t\t\toperands[i].type = \"NUMBR\";\n\t\t\t}\n\t\t\telse return `Error in line ${line_number}: ${operands[i].value} cannot be typecasted into a NUMBR or a NUMBR`;\n\t\t}\t\n\t}\n\n\tconst op1 = operands.shift();\n\tconst op2 = operands.shift();\n\n\tlet result;\n\tlet type;\n\tif (code === \"SUM OF\") result = op1.value + op2.value;\n\telse if (code === \"DIFF OF\") result = op1.value - op2.value;\n\telse if (code === \"PRODUKT OF\") result = op1.value * op2.value;\n\telse if (code === \"QUOSHUNT OF\") result = op1.value / op2.value;\n\telse if (code === \"MOD OF\") result = op1.value % op2.value;\n\telse if (code === \"BIGGR OF\") result = Math.max(op1.value,op2.value);\n\telse result = Math.min(op1.value,op2.value);\n\n\tif(op1.type === \"NUMBAR\" || op2.type === \"NUMBAR\") type = \"NUMBAR\";\n\telse\n\t{\n\t\tresult = Math.floor(result);\n\t\ttype = \"NUMBR\";\n\t} \n\treturn [result, type];\n}\n\nconst boolean_operations = (code, operands, line_number) =>\n{\n\tlet i;\n\tlet error;\n\tfor (i = 0; i<operands.length; i++){\n\t\tif(operands[i].type !== \"TROOF\")\n\t\t{\n\t\t\tlet name = (operands[i].name !== undefined)? operands[i].name : \"\";\n\t\t\terror = typecast_to_TROOF(operands[i].value, operands[i].type, name, line_number);\n\t\t\tif(!Array.isArray(error)) return error;\n\t\t\toperands[i].value = error[0];\n\t\t}\n\t}\n\tlet result;\n\tif (code === \"NOT\")\n\t{\n\t\tconst op1 = operands.shift();\n\t\tresult = (op1.value === \"WIN\")? \"FAIL\" : \"WIN\";\n\t}\n\telse if (code === \"ALL OF\")\n\t{\n\t\tresult = \"WIN\";\n\t\tfor(i = 0; i<operands.length; i++)\n\t\t{\n\t\t\tif(operands[i].value === \"FAIL\")\n\t\t\t{\n\t\t\t\tresult = \"FAIL\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse if (code === \"ANY OF\")\n\t{\n\t\tresult = \"FAIL\";\n\t\tfor(i = 0; i<operands.length; i++)\n\t\t{\n\t\t\tif(operands[i].value === \"WIN\")\n\t\t\t{\n\t\t\t\tresult = \"WIN\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tlet op1 = operands.shift();\n\t\tlet op2 = operands.shift();\n\t\top1 = (op1.value === \"WIN\")\n\t\top2 = (op2.value === \"WIN\")\n\n\t\tif (code === \"BOTH OF\") result = (op1 && op2);\n\t\telse if (code === \"EITHER OF\") result = (op1 || op2);\n\t\telse result = (op1 !== op2);\n\n\t\tresult = result ? \"WIN\" : \"FAIL\";\n\t}\n\treturn [result,\"TROOF\"];\n}\n\n\nconst comparison_operations = (code, operands, line_number) =>\n{\n\tlet result;\n\tconst op1 = operands.shift();\n\tconst op2 = operands.shift();\n\tresult = (op1.type === op2.type); // checks if op1 & op2 has same data types\n\tif (result) result = (op1.value === op2.value);\n\t// checks if true, if yes, checks if their value is equal and assigns it to result\n\tif (code === \"DIFFRINT\") result = !result;\n\t// checks if operation is different, if yes, negates result since all comparisons done is equality\n\t//conversion of boolean value to TROOF value\n\tif (result) result = \"WIN\"; // checks if result is true\n\telse result = \"FAIL\";\n\n\treturn [result, \"TROOF\"];\n}\n// if main lex == [], assignemnt is done on main\n// else assignemnt is done on flow-control statements and lexicon is FCS lexicon\nconst assignment_operation = (code, symbol_table, lexicon, func_table,line_number,handlePrefixChanges) =>\n{\n\tlet i = 0;\n\tlet error;\n\tfor (i; i<lexicon.length; i++)\n\t{\n\t\tif (lexicon[i].name === code.value)\n\t\t{\n\t\t\tlet cur_code = symbol_table.shift();\n\t\t\tif (cur_code.value === \"IS NOW\")\n\t\t\t{\n\t\t\t\tcur_code = symbol_table.shift();\n\t\t\t\tcur_code = symbol_table.shift();\n\t\t\t\terror = typecast(lexicon[i],cur_code.value,line_number);\n\t\t\t}\n\t\t\telse if (cur_code.value === \"\\n\")\n\t\t\t{\n\t\t\t\tlexicon[0].value = lexicon[i].value;\n\t\t\t\tlexicon[0].type = lexicon[i].type;\n\t\t\t}\n\t\t\telse error = recursive_operations(cur_code, symbol_table, lexicon, func_table,line_number,handlePrefixChanges);\n\t\t\t\n\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t[lexicon[i].value, lexicon[i].type] = error;\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (i === lexicon.length) return `Error on line ${line_number}: assigning value to an undeclared variable ${code.value}`;\n}\n\nconst SMOOSH = (operands, line_number) =>\n{\n\tlet i;\n\tlet concat = \"\";\n\tfor(i = 0; i<operands.length; i++)\n\t{\n\t\tif(operands[i].type !== \"YARN\")\n\t\t{\n\t\t\tlet name = operands[i].name;\n\t\t\tlet error = typecast_to_YARN(operands[i].value, operands[i].type, name, line_number);\n\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t[operands[i].value, operands[i].type] = error;\n\t\t}\n\t\tconcat += operands[i].value;\n\t}\n\treturn [concat, \"YARN\"];\n}\n\n\nconst ask_input = (symbol_table, lexicon, line_number,handlePrefixChanges) => \n{\n\tlet variable = symbol_table.shift();\n\tlet input = prompt(`GIMMEH ${variable.value}`);\n\tif(input === null) input = \"\";\n\tconst str = `${input}\\n`;\n\thandlePrefixChanges(str);\n\tlet type = \"YARN\";\n\tif(literal['NUMBR'][0].test(input))\n\t{\n\t\tinput = Number(input);\n\t\ttype = \"NUMBR\";\n\t}\n\telse if(literal['NUMBAR'][0].test(input))\n\t{\n\t\tinput = Number(input);\n\t\ttype = \"NUMBAR\";\n\t}\n\telse if(input === \"WIN\" || input === \"FAIL\") type = \"TROOF\";\n\n\tlet i = 0;\n\tfor(;i<lexicon.length; i++) if (lexicon[i].name === variable.value) break;\n\n\tif(i === lexicon.length) return `Error in line ${line_number}: GIMME is trying to assign to an undeclared variable`;\n\tlexicon[i].value = input;\n\tlexicon[i].type = type;\n\treturn false;\n}\n\nconst special_characters = (yarn, lexicon, line_number) =>\n{\n\tconst reg_newline = /\\:\\)/g;\n\tconst reg_tab = /\\:\\>/g;\n\tconst reg_beep = /\\:\\o/g;\n\tconst reg_doublequote = /\\:\\'/g;\n\tconst reg_colon = /\\:\\:/g;\n\tconst reg_variable = /\\:\\{[a-zA-Z][a-zA-Z0-9]*\\}/g\n\tconst reg_error = /\\:[^\\:]/;\n\n\t// if(reg_error.test(yarn) && reg_variable.test(yarn)) return `Error in line ${line_number}: escape character found without special character`;\n\tlet vars = yarn.match(reg_variable);\n\tif(vars != null)\n\t{\n\t\tlet i;\n\t\tlet j;\n\t\tlet value;\n\t\tlet new_str;\n\t\tlet to_replace = [];\n\t\tfor(i = 0; i<vars.length; i++)\n\t\t{\t\n\t\t\tnew_str = vars[i].slice(2,-1);\n\t\t\tfor(j = 0; j<lexicon.length; j++)\n\t\t\t{\n\t\t\t\tif(lexicon[j].name === new_str)\n\t\t\t\t{\n\t\t\t\t\tif(lexicon[j].value === undefined) return `Error in line ${line_number}: variable ${new_str} is uninitialized, NOOB cannot be typecasted into YARN`;\n\t\t\t\t\telse if(lexicon[j].type === \"NUMBR\") value = lexicon[j].value.toString();\n\t\t\t\t\telse if(lexicon[j].type === \"NUMBAR\") value = truncate(lexicon[j].value);\n\t\t\t\t\telse value = lexicon[j].value;\n\t\t\t\t\tto_replace.push(value);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j === lexicon.length) return `Error in line ${line_number}: variable ${vars[i]} is undeclared`;\n\t\t}\n\t\tfor(i = 0; i<vars.length; i++) yarn = yarn.replace(vars[i], to_replace[i]);\n\t}\n\tyarn = yarn.replace(reg_newline, \"\\n\");\n\tyarn = yarn.replace(reg_tab, \"\\t\");\n\tyarn = yarn.replace(reg_beep, \"\\g\");\n\tyarn = yarn.replace(reg_doublequote, \"\\\"\");\n\tlet sub = yarn.replace(reg_colon, \"\");\n\tif(reg_error.test(sub)) return `Error in line ${line_number}: escape character found without a special character`;\n\tyarn = yarn.replace(reg_colon, \"\\:\");\n\treturn [yarn];\n}\n\nconst truncate = (yarn) =>\n{\n\tyarn = yarn.toString();\n\tyarn = yarn.split(\".\")\n\tif(yarn.length === 1) yarn = yarn[0] + \".00\";\n\telse\n\t{\n\t\tif (yarn[1].length === 1) yarn[1] = yarn[1] + \"0\";\n\t\telse if(yarn[1].length > 2) yarn[1] = yarn[1].slice(0,2);\n\t\tyarn = yarn[0] + \".\" + yarn[1];\n\t}\n\treturn yarn;\n}\n\n\n/* NOTES OF SPECIAL CHARACTERS\n:) -> newline (\\n)\n:> -> tab (\\t)\n:o -> beep (\\g)\n:\" -> double quote (\")\n:: -> colon (:)\n:{var} -> typecasts value of var into string and adds to the string\n*/\nconst output = (symbol_table,lexicon, func_table,line_number, handlePrefixChanges) =>\n{\n\tlet code = symbol_table.shift();\n\tlet error;\n\tlet value;\n\tlet type;\n\tlet to_print = \"\";\n\tlet has_newline = true;\n\twhile(code.value !== \"\\n\" && code.value !== \",\")\n\t{\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase \"NUMBAR Literal\": to_print += truncate(code.value);\n\t\t\t\tbreak;\n\t\t\tcase 'No newline output': has_newline = false;\n\t\t\t\tbreak;\n\t\t\tcase \"NUMBR Literal\":\n\t\t\tcase \"TROOF Literal\": to_print += code.value;\n\t\t\t\tbreak;\n\t\t\tcase \"YARN Literal\": to_print += code.value.slice(1,-1);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (i; i<lexicon.length;i++)\n\t\t\t\t{\n\t\t\t\t\tif (lexicon[i].name === code.value)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(lexicon[i].value === undefined) return `Error in line ${line_number}: trying to print uninitialized variable ${code.value}`\n\t\t\t\t\t\telse if(lexicon[i].type === \"NUMBR\") to_print += lexicon[i].value.toString();\n\t\t\t\t\t\telse if(lexicon[i].type === \"NUMBAR\") to_print += truncate(lexicon[i].value);\n\t\t\t\t\t\telse to_print += lexicon[i].value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i===lexicon.length) return `Error in line ${line_number}: variable ${code.value} is undeclared`;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = recursive_operations(code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[value, type] = error;\n\t\t\t\tif(type === \"NUMBR\") to_print += value.toString();\n\t\t\t\telse if(type === \"NUMBAR\") to_print += truncate(value)\n\t\t\t\telse to_print += value;\n\t\t}\n\t\tcode = symbol_table.shift();\n\t}\n\n\tto_print += (has_newline)? \"\\n\": \"\";\n\terror = special_characters(to_print,lexicon,line_number);\n\tif(!Array.isArray(error)) return error;\n\tto_print = error[0];\n\thandlePrefixChanges(to_print);\n\tconsole.log(to_print);\n\treturn false;\n}\n\n// a function that handles variable declarations and initializations\nconst variable_dec_init = (symbol_table, lexicon, func_table, line_number,handlePrefixChanges) =>\n{\n\tlet code = symbol_table.shift(); // pops the first element of the array and gives it to code\n\tlet i;\n\t// value is expected to be a variable identifier\n\tconst name = code.value;\n\n\tfor(i=0; i<func_table; i++)\n\t{\n\t\tif(func_table[i].name === name) return `Error in line ${line_number}: ${name} is already a function identifier`;\n\t}\n\n\tif (name === \"IT\") return `Error in line ${line_number}: IT is an implicit variable and cannot be redeclared`;\n\tfor (i=1;i<lexicon.length; i++) if(lexicon[i].name === name) break;\n\tlet value = undefined\n\tlet type = \"NOOB\";\n\tlet error;\n\tcode = symbol_table.shift(); // gets next code\n\tif (code.value !== '\\n' && code.value !== \",\")\n\t{// iterates until it encounters a new line\n\t\terror = recursive_operations(code, symbol_table, lexicon, func_table,line_number,handlePrefixChanges);\n\t\tif(!Array.isArray(error)) return error;\n\t\t[value, type] = error;\t\t\n\t\tcode = symbol_table.shift(); // updating of iterator\n\t}\n\n\tif(i === lexicon.length)\n\t{\n\t\tlet variable = {name: name, value: value, type:type};\n\t\tlexicon.push(variable);\n\t}\n\telse\n\t{\n\t\tlexicon[i].value = value;\n\t\tlexicon[i].type = type;\t\n\t} \n\treturn false;\n}\n\nconst typecast = (operand, type, line_number) =>\n{\n\tlet value;\n\tif(type === \"YARN\") value = typecast_to_YARN(operand.value, operand.type, operand.name, line_number);\n\telse if(type === \"NUMBR\") value = typecast_to_NUMBR(operand.value, operand.type, operand.name, line_number);\n\telse if(type === \"NUMBAR\") value = typecast_to_NUMBAR(operand.value, operand.type, operand.name, line_number);\n\telse if(type === \"TROOF\") value = typecast_to_TROOF(operand.value, operand.type, operand.name, line_number);\n\telse return `Error in line ${line_number}: typecasting into NOOB is not allowed`;\n\tif(!Array.isArray(value)) return value;\n\treturn value;\n}\n\nconst typecast_to_YARN = (value, type, name, line_number) =>\n{\n\tif(type === \"NOOB\") return `Error in line ${line_number}: cannot typecast NOOB to YARN`;\n\telse if(value === undefined) return `Error in line ${line_number}:variable ${name} is uninitialized`;\n\telse if (type === \"NUMBR\" || type === \"NUMBAR\") value = value.toString();\n\treturn [value, \"YARN\"];\n}\n\nconst typecast_to_NUMBR = (value, type, name, line_number) =>\n{\n\tif (type === \"NOOB\") return `Error in line ${line_number}: NOOB value cannot by implicitly typecasted into a NUMBR`;\n\telse if (value === undefined) return `Error in line ${line_number}: variable ${name} is uninitialized before use`;\n\telse if (type === \"TROOF\") value = (value === \"WIN\")? 1 : 0;\n\telse if (type === \"NUMBAR\") value = Math.floor(value);\n\telse\n\t{\n\t\tif (literal['NUMBAR'][0].test(value) || literal['NUMBR'][0].test(value))\n\t\t{\n\t\t\tvalue = Number(value);\n\t\t\tvalue = Math.floor(value);\n\t\t}\n\t\telse return `Error in line ${line_number}: ${value} cannot be typecasted into a NUMBR`;\n\t}\n\treturn [value, \"NUMBR\"];\n}\n\nconst typecast_to_NUMBAR = (value, type, name, line_number) =>\n{\n\tif (type === \"NOOB\") return `Error in line ${line_number}: NOOB value cannot by implicitly typecasted into a NUMBR`;\n\telse if (value === undefined) return `Error in line ${line_number}: variable ${name} is uninitialized before use`;\n\telse if (type === \"TROOF\") value = (value === \"WIN\")? 1 : 0;\n\telse if (type === \"YARN\")\n\t{\n\t\t// const check = value;\n\t\tif (literal['NUMBAR'][0].test(value) || literal['NUMBR'][0].test(value)) value = Number(value);\n\t\telse return `Error in line ${line_number}: ${value} cannot be typecasted into a NUMBAR`;\n\t}\n\treturn [value,\"NUMBAR\"];\t\n}\n\n// return [value, \"TROOF\"] or error prompt\nconst typecast_to_TROOF = (value, type, name, line_number) =>\n{\n\tif (type === \"NOOB\") return [\"FAIL\",\"TROOF\"];\n\telse if(value === undefined) return `Error in line ${line_number}: variable ${name} is uninitialized before use`;\n\telse if(type === \"NUMBAR\" || type === \"NUMBR\") value = (value !== 0)? \"WIN\": \"FAIL\";\n\telse\n\t{\n\t\tif(value === \"WIN\") value =  \"WIN\";\n\t\telse if (value === \"FAIL\") value = \"FAIL\";\n\t\telse if(literal['NUMBR'][0].test(value) || literal['NUMBAR'][0].test(value)) value = (Number(value) !== 0)? \"WIN\": \"FAIL\";\n\t\telse value = (value !== \"\")? \"WIN\": \"FAIL\";\n\t}\n\treturn [value,\"TROOF\"];\n} \n\n// return line number\nconst skip_control = (symbol_table, line_number) =>\n{\n\tlet code = symbol_table.shift();\n\twhile(code.value !== \"OIC\")\n\t{\n\t\tif(code.value === \"\\n\") line_number++;\n\t\telse if(code.value === \"O RLY\") line_number = skip_control(symbol_table, line_number);\n\t\telse if(code.value === \"WTF\") line_number = skip_control(symbol_table, line_number);\n\t\tcode = symbol_table.shift();\n\t}\n\n\treturn line_number;\n}\n\n// return [line_number, found_break] or error prompt\nconst if_else_control = (symbol_table, lexicon, func_table, line_number, switch_loop,handlePrefixChanges) =>\n{\n\tlet checker = {value:lexicon[0].value, type:lexicon[0].type};\n\tlet error = typecast_to_TROOF(checker.value, checker.type);\n\tif(!Array.isArray(error)) return error;\n\t[checker.value, checker.type] = error;\n\tconst prev_length = lexicon.length;\n\tlet found = (checker.value === \"WIN\");\n\tlet code = symbol_table.shift();\n\tlet prev_func = func_table.length;\n\twhile(code.value !== \"OIC\")\n\t{\n\t\tif(found) break;\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase 'Switch Case Delimiter Keyword':\n\t\t\tcase 'If-Else Delimiter Keyword': line_number = skip_control(symbol_table,line_number);\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword': error = skip_loop(symbol_table,line_number,0);\n\t\t\t\tline_number = error[1];\n\t\t\t\tsymbol_table.splice(0,error[0]+1);\n\t\t\t\tbreak;\n\t\t\tcase 'Line Break': line_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Else-If Keyword':\n\t\t\t\terror = recursive_operations(code, symbol_table, lexicon, func_table,line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[checker.value, checker.type] = error;\n\t\t\t\tline_number++;\n\t\t\t\terror = typecast_to_TROOF(checker.value, checker.type);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[checker.value, checker.type] = error;\n\t\t\t\tfound = (checker.value === \"WIN\");\n\t\t\t\tbreak;\n\t\t\tcase 'Else Keyword': found = true;\n\t\t}\n\t\tcode = symbol_table.shift();\n\t}\n\n\tlet found_break = false;\n\tlet to_continue = found;\n\twhile(to_continue && code.value !== \"OIC\")\n\t{\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase 'If-Else Delimiter Keyword': error = if_else_control(symbol_table, lexicon, func_table ,line_number, switch_loop,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[line_number,found_break] = error;\n\t\t\t\tif(found_break) to_continue = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Line Break': line_number++;\n\t\t\tcase 'If Keyword':\n\t\t\tcase 'Control Flow Delimiter':\n\t\t\tcase 'Command Line Break': break;\n\t\t\tcase 'Else-If Keyword': \n\t\t\tcase 'Else Keyword': to_continue = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Function Delimeter Keyword':\n\t\t\t\terror = get_function(symbol_table, lexicon, func_table, line_number);\n\t\t\t\tif(error) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword': error = loop(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tline_number = error;\n\t\t\t\tbreak;\n\t\t\tcase 'Break Keyword': if(!switch_loop) return `Error in line ${line_number}: GTFO encountered while not inside a switch case or a loop`;\n\t\t\t\tto_continue = false;\n\t\t\t\tfound_break = true;\n\t\t\t\tbreak; \n\t\t\tcase 'Switch Case Delimiter Keyword': error = switch_control(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tline_number = error;\n\t\t\t\tbreak;\n\t\t\tcase 'Variable Declaration Keyword': \n\t\t\t\terror = variable_dec_init(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Identifier': assignment_operation(code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Output Keyword':\n\t\t\t\terror = output(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'Input Keyword': error = ask_input(symbol_table, lexicon,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tdefault: error = recursive_operations(code, symbol_table, lexicon, func_table,line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[lexicon[0].value, lexicon[0].type] = error;\n\t\t\t\tline_number++;\t\n\t\t}\n\t\tcode = symbol_table.shift();\n\t}\n\n\tconst to_remove = lexicon.length - prev_length;\n\tconst del_func = func_table.length - prev_func;\n\tif(to_remove > 0) lexicon.splice(-to_remove,to_remove);\n\tif(del_func > 0) func_table.splice(-del_func, del_func);\n\tif(code.value !== \"OIC\") line_number = skip_control(symbol_table, line_number);\n\treturn [line_number, found_break];\n}\n\n// return [code.value, line number] or error prompt\nconst execute_switch = (symbol_table, lexicon, func_table, line_number,handlePrefixChanges) =>\n{\n\tlet to_continue = true;\n\tlet found_break;\n\tlet value;\n\tlet type;\n\tlet error;\n\tlet code = symbol_table.shift();\n\twhile(to_continue && code.value !== \"OIC\")\n\t{\n\t\tcode = symbol_table.shift();\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase 'If-Else Delimiter Keyword': error = if_else_control(symbol_table, lexicon, func_table ,line_number, true,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[line_number,found_break] = error;\n\t\t\t\tif(found_break) to_continue = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Switch Case Delimiter Keyword': error = switch_control(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'Function Delimeter Keyword':\n\t\t\t\terror = get_function(symbol_table, lexicon, func_table, line_number);\n\t\t\t\tif(error) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'Line Break': line_number++;\n\t\t\tcase 'Control Flow Delimiter':\n\t\t\tcase 'Command Line Break': break;\n\t\t\tcase 'Flow-Control Delimiter Keyword':\n\t\t\tcase 'Break Keyword': to_continue = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword': error = loop(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tline_number = error;\n\t\t\t\tbreak;\n\t\t\tcase 'Variable Declaration Keyword': \n\t\t\t\terror = variable_dec_init(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Identifier': assignment_operation(code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Output Keyword':\n\t\t\t\terror = output(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Input Keyword': error = ask_input(symbol_table, lexicon,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Case-Default Keyword':\n\t\t\tcase 'Case Keyword': code = symbol_table.shift();\n\t\t\t\tbreak;\n\t\t\tdefault: error = recursive_operations(code, symbol_table, lexicon, func_table,line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[value, type] = error;\n\t\t\t\tlexicon[0].value = value;\n\t\t\t\tlexicon[0].type = type;\n\t\t\t\tline_number++;\t\n\t\t}\n\t}\n\n\treturn [code.value, line_number];\n}\n\n// return line number, or error prompt\nconst switch_control = (symbol_table, lexicon, func_table, line_number,handlePrefixChanges) =>\n{\n\tconst holder = {value:lexicon[0].value, type:lexicon[0].type};\n\tlet to_break = false;\n\tlet to_compare;\n\tlet value;\n\tlet type;\n\tlet error;\n\tconst prev_length = lexicon.length;\n\tlet prev_func = func_table.length;\n\tlet code = symbol_table.shift();\n\n\twhile(code.value !== \"OIC\")\n\t{\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase 'Line Break': line_number++;\n\t\t\tcase 'Command Line Break':\n\t\t\tcase 'Control Flow Delimiter': break;\n\t\t\tcase 'Switch Case Delimiter Keyword':\n\t\t\tcase 'If-Else Delimiter Keyword': line_number = skip_control(symbol_table, line_number);\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword': error = skip_loop(symbol_table,line_number,0);\n\t\t\t\tline_number = error[1];\n\t\t\t\tsymbol_table.splice(0,error[0]+1);\n\t\t\t\tbreak;\n\t\t\tcase 'Case Keyword':\n\t\t\t\terror = recursive_operations(code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[value, type] = error;\n\t\t\t\tto_compare = {value:value, type:type};\n\t\t\t\tif((holder.type === to_compare.type) && (holder.value === to_compare.value))\n\t\t\t\t{\n\t\t\t\t\terror = execute_switch(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t\tline_number = error[1];\n\t\t\t\t\tto_break = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Case-Default Keyword':\n\t\t\t\terror = execute_switch(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\tline_number = error[1];\n\t\t\t\tto_break = true;\n\t\t\t\tbreak;\n\t\t}\n\t\tif(to_break) break;\n\t\tcode = symbol_table.shift();\n\t}\n\n\tconst to_remove = lexicon.length - prev_length;\n\tconst del_func = func_table.length - prev_func;\n\tif(to_remove > 0) lexicon.splice(-to_remove,to_remove);\n\tif(del_func > 0) func_table.splice(-del_func, del_func);\n\tif(code.value !== \"OIC\" && error[0] !== \"OIC\") line_number = skip_control(symbol_table, line_number);\n\treturn line_number;\n}\n\n// skiploop, hopp\nconst skip_loop = (symbol_table, line_number,index) =>\n{\n\twhile(symbol_table[index].value !== \"IM OUTTA\") \n\t{\n\t\tindex++;\n\t\tif(symbol_table[index].value === \"\\n\") line_number++;\n\t\telse if (symbol_table[index].value === \"IM IN\") [index, line_number] = skip_loop(symbol_table, line_number, index);\n\t}\n\tindex +=2;\n\treturn [index, line_number];\n}\n\nconst get_function = (symbol_table, lexicon, func_table, line_number) =>\n{\n\tlet code_list = [];\n\tlet code = symbol_table.shift();\n\tlet name = code.value\n\tlet error;\n\tfor(let i = 0; i<lexicon.length; i++)\n\t{\n\t\tif(lexicon[i].name === name) return `Error in line ${line_number}: ${name} is already a variable identifier`;\n\t}\n\t\n\tlet parameters = [];\n\twhile(code.value !== \"\\n\")\n\t{\n\t\tif(code.description === \"Parameter Identifier\") parameters.push(code.value);\n\t\tcode_list.push(code);\n\t\tcode = symbol_table.shift();\n\t}\n\twhile(code.value !== \"IF U SAY SO\")\n\t{\n\t\tif(code.description === \"Function Delimeter Keyword\")\n\t\t{\n\t\t\twhile(code.value !== \"IF U SAY SO\")\n\t\t\t{\n\t\t\t\tcode_list.push(code);\n\t\t\t\tcode = symbol_table.shift();\n\t\t\t}\n\t\t}\n\t\tcode_list.push(code);\n\t\tcode = symbol_table.shift();\n\t}\n\tcode_list.push(code);\n\tcode = code_list.shift();\n\twhile(code.value !== \"\\n\") code = code_list.shift();\n\n\tconst new_func = {name:name, parameters:parameters, arity:parameters.length, code:code_list, line:line_number};\n\tfor (let i = 0; i<func_table.length; i++)\n\t{\n\t\tif(func_table[i].name === name)\n\t\t{\n\t\t\tif(func_table[i].arity === parameters.length) return `Error in line ${line_number}: function ${name} declared twice`;\n\t\t\telse break;\n\t\t}\n\t}\n\tfunc_table.push(new_func);\n\treturn false;\n}\n\nconst eval_function = (operands, lexicon, func_table, line_number,handlePrefixChanges) =>\n{\n\tconst name = operands.shift();\n\tconst prev_func = func_table.length;\n\tconst prev_length = lexicon.length;\n\tlet i = 0;\n\tlet pos_arity = [];\n\tfor(i;i<func_table.length; i++)\n\t{\n\t\tif(name === func_table[i].name) \n\t\t{\n\t\t\tif(operands.length === func_table[i].arity) break;\n\t\t\telse pos_arity.push(func_table[i].arity);\n\t\t}\n\t}\n\tif(i === func_table.length) \n\t{\n\t\tif(pos_arity.length === 0) return `Error in line ${line_number}: function ${name} is not declared`;\n\t\telse\n\t\t{\n\t\t\tlet to_print = \"\";\n\t\t\tif(pos_arity.length === 1) return `Error in line ${line_number}: function ${name} accepts ${pos_arity[0]} operands, but got ${operands.length} operands`;\n\t\t\tfor(i=0; i<pos_arity.length-1; i++) to_print += pos_arity[i] + \", \";\n\t\t\tto_print += `or ${pos_arity[pos_arity.length-1]} `;\n\t\t\treturn `Error in line ${line_number}: function ${name} accepts ${to_print}operands, but got ${operands.length} operands`;\n\t\t}\n\t}\n\n\tlet j = 0;\n\tlet k = 0;\n\tlet param;\n\n\twhile(operands.length !== 0)\n\t{\n\t\tparam = operands.shift();\n\t\tfor(; k<lexicon.length; k++)\n\t\t{\n\t\t\tif(lexicon[k].name === func_table[i].parameters[j])\n\t\t\t{\n\t\t\t\tlexicon[k].value = param.value;\n\t\t\t\tlexicon[k].type = param.type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(k === lexicon.length) lexicon.push({value:param.value, type:param.type, name:func_table[i].parameters[j]});\n\t\tj++;\n\t}\t\n\n\tline_number = func_table[i].line;\n\n\tlet cur_table = func_table[i].code.slice(0);\n\tlet code = cur_table.shift();\n\tlet error;\n\twhile(code.value !== \"IF U SAY SO\")\n\t{\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase 'Line Break': line_number++;\n\t\t\tcase 'Command Line Break': break;\n\t\t\tcase 'Function Return Keyword': error = recursive_operations(code, cur_table,lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\treturn error;\n\t\t\tcase 'Function Delimeter Keyword':\n\t\t\t\terror = get_function(cur_table, lexicon, func_table, line_number);\n\t\t\t\tif(error) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'Variable Declaration Keyword': \n\t\t\t\terror = variable_dec_init(cur_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Identifier':\n\t\t\t\tif(code.value === \"NOOB\")\n\t\t\t\t{\n\t\t\t\t\tlexicon[0].value = undefined;\n\t\t\t\t\tlexicon[0].type = \"NOOB\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\terror = assignment_operation(code, cur_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Output Keyword':\n\t\t\t\terror = output(cur_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Input Keyword': error = ask_input(cur_table, lexicon,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Code Delimiter Keyword': break;\n\t\t\tcase 'Switch Case Delimiter Keyword': error = switch_control(cur_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tline_number = error;\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword':\n\t\t\t\tif(code.value === \"IM IN\") error = loop(cur_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'If-Else Delimiter Keyword': error = if_else_control(cur_table, lexicon, func_table ,line_number,false,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\tline_number = error[0];\n\t\t\t\tbreak;\n\t\t\tdefault: error = recursive_operations(code, cur_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[lexicon[0].value, lexicon[0].type] = error;\n\t\t\t\tline_number++;\t\n\t\t}\n\t\tcode = cur_table.shift();\n\t}\n\n\tconst to_remove = lexicon.length - prev_length;\n\tconst del_func = func_table.length - prev_func;\n\tif(to_remove > 0) lexicon.splice(-to_remove, to_remove);\n\tif(del_func > 0) func_table.splice(-del_func,del_func);\n\treturn [lexicon[0].value, lexicon[0].type];\n\n}\n\n// return current line number or error prompt\nconst loop = (symbol_table, lexicon, func_table,line_number,handlePrefixChanges) =>\n{\n\tlet i = 0;\n\tlet update;\n\tlet cur_line_num = line_number;\n\tconst prev_length = lexicon.length;\n\tlet loop_label\n\tlet loop_var;\n\tlet loop_start;\n\tlet check;\n\tfor(; i<symbol_table.length; i++)\n\t{\n\t\tif(symbol_table[i].value === \"IM OUTTA\")\n\t\t{\n\t\t\ti+=2;\n\t\t\tif(symbol_table[i].value !== loop_label) return `Error in line ${cur_line_num}: Loop labels are mismatched`;\n\t\t\tbreak;\n\t\t}\n\t\telse if (symbol_table[i].value === \"IM IN\") [i,cur_line_num] = skip_loop(symbol_table,cur_line_num, i); \n\t\telse if (symbol_table[i].value === \"\\n\") cur_line_num++;\n\t\telse if (symbol_table[i].value === \"UPPIN\") update = 1;\n\t\telse if (symbol_table[i].value === \"NERFIN\") update = -1;\n\t\telse if (symbol_table[i].description === \"Loop Keyword\")\n\t\t{\n\t\t\tcheck = (symbol_table[i].value === \"WILE\")? \"WIN\": \"FAIL\";\n\t\t\tloop_start = i+1;\n\t\t}\n\t\telse if (symbol_table[i].description === 'Loop Identifier') loop_label = symbol_table[i].value;\n\t\telse if (symbol_table[i].description === 'Parameter Identifier') loop_var = symbol_table[i].value;\n\t}\n\tconst placeholder = i+1;\n\tlet table = symbol_table.slice(0,i+1);\n\tfor(i = 0; i<lexicon.length; i++) if(lexicon[i].name === loop_var) break;\n\tif(i === lexicon.length) return `Error in line ${cur_line_num}: variable ${loop_var} is uninitialized`;\n\tloop_var = i;\n\n\tlet value;\n\tlet type;\n\tlet loop_copy = table.slice(loop_start);\n\tlet error = recursive_operations(loop_copy.shift(), loop_copy,lexicon, func_table, line_number,handlePrefixChanges);\n\tif(!Array.isArray(error)) return error;\n\t[value, type] = error;\n\tif(type !== \"TROOF\")\n\t{\n\t\terror = typecast_to_TROOF(value, type, \"\", cur_line_num);\n\t\tif(!Array.isArray(error)) return error;\n\t\t[value, type] = error;\n\t}\n\tlet to_continue = (check === value);\n\tlet code = loop_copy.shift();\n\n\twhile(to_continue)\n\t{\n\t\tswitch(code.description)\n\t\t{\n\t\t\tcase 'Line Break': cur_line_num++;\n\t\t\tcase 'Flow-Control Delimiter Keyword':\n\t\t\tcase 'Parameter Delimiter Keyword':\n\t\t\tcase 'Command Line Break': break;\n\t\t\tcase 'Break Keyword': to_continue = false;\n\t\t\t\tbreak;\n\t\t\tcase 'Switch Case Delimiter Keyword': error = switch_control(loop_copy, lexicon, func_table, cur_line_num,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error\n\t\t\t\tcur_line_num = error;\n\t\t\t\tbreak;\n\t\t\tcase 'If-Else Delimiter Keyword': error = if_else_control(loop_copy, lexicon, func_table,cur_line_num,true,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\tcur_line_num = error[0];\n\t\t\t\tto_continue = !error[1]; // error[1] is found break\n\t\t\t\tbreak;\n\t\t\tcase 'Variable Declaration Keyword': \n\t\t\t\terror = variable_dec_init(loop_copy, lexicon, func_table, cur_line_num,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tcur_line_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'Identifier': \n\t\t\t\tassignment_operation(code, loop_copy, lexicon, func_table, cur_line_num,handlePrefixChanges);\n\t\t\t\tcur_line_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'Output Keyword':\n\t\t\t\terror = output(loop_copy, lexicon, func_table, cur_line_num,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tcur_line_num++;\n\t\t\t\tbreak;\n\t\t\tcase 'Input Keyword': error = ask_input(loop_copy, lexicon, cur_line_num,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword':\n\t\t\t\tif(code.value === \"IM OUTTA\")\n\t\t\t\t{\n\t\t\t\t\tlexicon[loop_var].value+=update;\n\t\t\t\t\tloop_copy = table.slice(loop_start);\n\t\t\t\t\terror = recursive_operations(loop_copy.shift(), loop_copy,lexicon, func_table,line_number,handlePrefixChanges);\n\t\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t\t[value, type] = error;\n\t\t\t\t\tif(type !== \"TROOF\")\n\t\t\t\t\t{\n\t\t\t\t\t\terror = typecast_to_TROOF(value, type, \"\", cur_line_num);\n\t\t\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t\t\t[value, type] = error;\n\t\t\t\t\t}\n\t\t\t\t\tcur_line_num = line_number;\n\t\t\t\t\tto_continue = (check === value);\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror = loop(loop_copy, lexicon, func_table, cur_line_num,handlePrefixChanges);\n\t\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\t\tcur_line_num = error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault: \n\t\t\t\terror = recursive_operations(code, loop_copy, lexicon, func_table,line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[value, type] = error;\n\t\t\t\tlexicon[0].value = value;\n\t\t\t\tlexicon[0].type = type;\n\t\t\t\tcur_line_num++;\t\n\t\t}\n\t\tcode = loop_copy.shift();\n\t}\n\n\n\tsymbol_table.splice(0,placeholder);\n\tconst to_remove = lexicon.length - prev_length;\n\tif(to_remove > 0) lexicon.splice(-to_remove,to_remove);\n\treturn cur_line_num;\n}\n\n\n// return lexicon (variable table) or error prompt\nexport const program_start = (symbol_table,handlePrefixChanges) =>\n{\n\tif(symbol_table.length === []) return \"Cannot evaluate syntactically incorrect code\";\n\tremoveComments(symbol_table); // removes comments in the symbol table\n\tlet line_number = 1;\n\tlet error;\n\tlet code;\n\tlet func_table = [];\n\tlet lexicon = [{name:\"IT\", value:undefined, type:\"NOOB\"}];\n\twhile(symbol_table.length !== 0)\n\t{\n\t\tcode = symbol_table.shift();\n\t\tswitch (code.description)\n\t\t{\n\t\t\tcase 'Line Break': line_number++;\n\t\t\tcase 'Command Line Break': break;\n\t\t\tcase 'Function Delimeter Keyword':\n\t\t\t\terror = get_function(symbol_table, lexicon, func_table, line_number);\n\t\t\t\tif(error) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'Variable Declaration Keyword': \n\t\t\t\terror = variable_dec_init(symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Identifier':\n\t\t\t\tif(code.value === \"NOOB\")\n\t\t\t\t{\n\t\t\t\t\tlexicon[0].value = undefined;\n\t\t\t\t\tlexicon[0].type = \"NOOB\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\terror = assignment_operation(code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Output Keyword':\n\t\t\t\terror = output(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Input Keyword': error = ask_input(symbol_table, lexicon,line_number,handlePrefixChanges);\n\t\t\t\tif(error) return error;\n\t\t\t\tline_number++;\n\t\t\t\tbreak;\n\t\t\tcase 'Code Delimiter Keyword': break;\n\t\t\tcase 'Switch Case Delimiter Keyword': error = switch_control(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tline_number = error;\n\t\t\t\tbreak;\n\t\t\tcase 'Loop Delimiter Keyword':\n\t\t\t\tif(code.value === \"IM IN\") error = loop(symbol_table, lexicon, func_table ,line_number,handlePrefixChanges);\n\t\t\t\tif(!Number.isInteger(error)) return error;\n\t\t\t\tbreak;\n\t\t\tcase 'If-Else Delimiter Keyword': error = if_else_control(symbol_table, lexicon, func_table ,line_number,false,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\tline_number = error[0];\n\t\t\t\tbreak;\n\t\t\tdefault: error = recursive_operations(code, symbol_table, lexicon, func_table, line_number,handlePrefixChanges);\n\t\t\t\tif(!Array.isArray(error)) return error;\n\t\t\t\t[lexicon[0].value, lexicon[0].type] = error;\n\t\t\t\tline_number++;\n\t\t}\t\n\t}\n\n\tfor(let i = 0; i < lexicon.length; i++)\n\t{\n\t\tif (lexicon[i].type === \"NUMBAR\" && lexicon[i].value !== undefined) lexicon[i].value = truncate(lexicon[i].value);\n\t\telse if(lexicon[i].value === undefined) lexicon[i].value = \"NOOB\";\n\t}\n\n\treturn lexicon\n}\n","/home/xera/web-projects/LOLCODE_Project/src/utils/lexemes.js",["99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116"],"export const keywords = \n    {\n        \"HAI\":['Start','Code Delimiter Keyword'],\n        \"KTHXBYE\":['End','Code Delimiter Keyword'],\n        \"BTW\":['Comment','Line Comment Keyword'],\n        \"OBTW\":['Multi-Line Comment Start','Comment Delimiter Keyword'],\n        \"TLDR\":['Multi-Line Comment End','Comment Delimiter Keyword'],\n        \"I HAS A\":['Declare Var','Variable Declaration Keyword'],\n        \"ITZ\":['Initialize Var','Variable Initialization Keyword'],\n        \"R\":['Assigment Var','Variable Assignment Keyword'],\n        \"SUM OF\":['Arithmetic','Addition Operation Keyword'],\n        \"DIFF OF\":['Arithmetic','Subtraction Operation Keyword'],\n        \"PRODUKT OF\":['Arithmetic','Multiplication Operation Keyword'],\n        \"QUOSHUNT OF\":['Arithmetic','Division Operation Keyword'],\n        \"MOD OF\":['Arithmetic','Modulo Operation Keyword'],\n        \"BIGGR OF\":['Arithmetic','Max Operation Keyword'],\n        \"SMALLR OF\":['Arithmetic','Min Operation Keyword'],\n        \"BOTH OF\":['Boolean','AND Operation Keyword'],\n        \"EITHER OF\":['Boolean','OR Operation Keyword'],\n        \"WON OF\":['Boolean','XOR Operation Keyword'],\n        \"NOT\":['Boolean','NOT Operation Keyword'],\n        \"ANY OF\":['Boolean Many','OR Delimiter Operation Keyword'],\n        \"ALL OF\":['Boolean Many','AND Delimiter Operation Keyword'],\n        \"BOTH SAEM\":['Comparison','Equal Operation Keyword'],\n        \"DIFFRINT\":['Comparison','Not Equal Operation Keyword'],\n        \"SMOOSH\":['Concat','Concatenation Operation Keyword'],\n        \"MAEK\":['Declare Typecast','Type Casting Declaration Keyword'],\n        \"IS NOW\":['Initialize Typecast','Type Casting Initialization Keyword'],\n        \"A\":['Type Keyword','Type Keyword'],\n        \"VISIBLE\":['Output','Output Keyword'],\n        \"GIMMEH\":['Input','Input Keyword'],\n        \"O RLY\":['If-Else','If-Else Delimiter Keyword'],\n        \"YA RLY\":['If','If Keyword'],\n        \"MEBBE\":['Else-If','Else-If Keyword'],\n        \"NO WAI\":['Else','Else Keyword'],\n        \"OIC\":['Flow-Control End','Flow-Control Delimiter Keyword'],\n        \"WTF\":['Switch','Switch Case Delimiter Keyword'],\n        \"OMG\":['Switch Option','Case Keyword'],\n        \"OMGWTF\":['Switch Default','Case-Default Keyword'],\n        \"GTFO\":['Break','Break Keyword'],\n        \"IM IN\":['Loop','Loop Delimiter Keyword'],\n        \"YR\":['Delimiter','Parameter Delimiter Keyword'],\n        \"UPPIN\":['Loop Inc','Increment Keyword'],\n        \"NERFIN\":['Loop Dec','Decrement Keyword'],\n        \"TIL\":['Loop Cond','Loop Keyword'],\n        \"WILE\":['Loop Cond','Loop Keyword'],\n        \"IM OUTTA\":['Loop End','Loop Delimiter Keyword'],\n        \"AN\":['Conjunction','Operand Delimiter Keyword'],\n        \"HOW IZ I\":['Function', 'Function Delimeter Keyword'],\n        \"IF U SAY SO\":['Function End', 'Function Delimeter Keyword'],\n        \"FOUND\": ['Function Return','Function Return Keyword'],\n        \"I IZ\":['Function Call', 'Function Call Keyword'],\n        \"NUMBR\":['Type','NUMBR Type Keyword'],\n        \"NUMBAR\":['Type','NUMBAR Type Keyword'],\n        \"YARN\":['Type','YARN Type Keyword'],\n        \"TROOF\":['Type','TROOF Type Keyword'],\n        \"MKAY\":['Boolean Many','Infinite Delimiter Keyword'],\n    }\n\n\nexport const literal = {\n    \"NUMBR\":[/(^\\-?[0-9]+$)/,'NUMBR Literal'],\n    \"NUMBAR\":[/(^\\-?[0-9]*\\.[0-9]+$)/,'NUMBAR Literal'],\n    \"YARN1\":[/(^[\\\"]([^\\\"]|(\\:\\\"))*$)/,'YARN Literal'],\n    \"YARN2\":[/(^([^\\\"]|(\\:\\\"))*[\\\"][\\!\\,]{0,2}$)/,'YARN Literal'],\n    \"YARN\":[/(^[\\\"]([^\\\"]|(\\:\\\"))*[\\\"]$)/,'YARN Literal'],\n    \"TROOF\":[/^((WIN)|(FAIL))$/,'TROOF Literal'],\n}\n\nexport const identifier = [/^([A-Za-z]+[0-9\\_]*)$/,'Identifier']\n\nexport const types = {\n    \"NUMBR\":['Type','NUMBR Type'],\n    \"NUMBAR\":['Type','NUMBAR Type'],\n    \"YARN\":['Type','YARN Type'],\n    \"TROOF\":['Type','TROOF Type'],\n    \"NOOB\" : ['Type','NOOB Type'],\n}\n\n","/home/xera/web-projects/LOLCODE_Project/src/utils/parser.js",["117","118","119","120","121","122","123","124","125","126","127","128","129","130"],"import { keywords , literal ,identifier, types} from './lexemes';\n\n// inline comment abstraction //okay\nconst inline_comment_abs = (code, tableOfLexemes,lineNumber)=>{\n    code[0] = code[0].join(\" \").trim().split(\" \");\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    // if there is comment after BTW\n    if(code[0].length !== 0){\n        placeholder = code[0].join(\" \");\n        tableOfLexemes.push({value:placeholder,description:'Comment'});\n        code[0] = [];\n    }\n    return [code, tableOfLexemes, lineNumber];\n}\n\n// multiline comment abstraction //okay\nconst multiline_comment_abs = (code, tableOfLexemes, lineNumber) =>{\n    let placeholder = code[0].shift(),error,indexTLDR;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    // getting all the comment before the line of TLDR\n    while(!code[0].includes('TLDR')){\n        placeholder = code.shift().join(\" \").trim();\n        if(placeholder !== \"\"){\n            tableOfLexemes.push({value:placeholder,description:'Comment'});\n        }\n        tableOfLexemes.push({value:'\\n',description:'Line Break'});\n        // if there is no TLDR present in the code\n        if(code.length === 0) return `Syntax Error in line ${lineNumber}: Expected end of Multi-Line Comment.`;\n        code[0]=code[0].trim().split(\" \");\n        error = tokenizer_abs(code,lineNumber);\n        if(!Array.isArray(error)) return error;\n        [code, lineNumber] = error;\n        lineNumber++;\n    }\n    indexTLDR = code[0].indexOf(\"TLDR\");\n    // if there is comment before TLDR\n    if(indexTLDR !== 0){\n        placeholder = code[0].slice(0,indexTLDR).join(\" \").trim();\n        tableOfLexemes.push({value:placeholder,description:'Comment'});\n    }\n    tableOfLexemes.push({value:'TLDR',description:keywords['TLDR'][1]});\n    code[0] = code[0].slice(indexTLDR+1,code[0].length).join(\" \").trim().split(\" \");\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }if(code[0][0] === '' && code[0].length ===1){\n        code[0].shift();\n    }\n    return [code, tableOfLexemes, lineNumber];\n}\n\n// literal abstraction //okay\nconst literal_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),isChanged = true;\n    if(literal[\"NUMBAR\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"NUMBAR\"][1]});\n    }else if(literal[\"NUMBR\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"NUMBR\"][1]});\n    }else if(literal[\"YARN\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"YARN\"][1]});\n    }else if(literal[\"TROOF\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"TROOF\"][1]});\n    }else{\n        code[0].unshift(placeholder);\n        isChanged = false;\n    }\n    // if command line break encountered\n    if(isChanged && code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged];\n}\n\n// identifier abstraction //okay\nconst identifier_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    if(placeholder[0] === '\\'' &&  placeholder[placeholder.length-1] === '\\''){\n        // if there are string that were enclose by single quotes\n        return `Syntax Error in line ${lineNumber}: Unexpected Sequence: ${placeholder}.`;\n    }else if(keywords[placeholder] || [\"WIN\",\"FAIL\"].includes(placeholder) || !identifier[0].test(placeholder)){\n        // invalid format of the identifier\n        return `Syntax Error in line ${lineNumber}: Expected Identifier: ${placeholder}.`;\n    }else{\n        tableOfLexemes.push({value:placeholder, description: identifier[1]});\n    }\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// operands abstraction //okay\nconst operands_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let error,isChanged;\n    // literal\n    [code,tableOfLexemes, lineNumber, isChanged] = literal_abs(code,tableOfLexemes,lineNumber);\n    // expression\n    if(!isChanged){\n        error = expression_abs(code,tableOfLexemes,lineNumber,type);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber, isChanged] = error;\n    }\n    // identifier\n    if(!isChanged){\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// output abstraction //okay\nconst output_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift() , error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(tableOfLexemes[tableOfLexemes.length-1].value === \"VISIBLE\" && (code[0].join(\" \").trim().split(\" \")[0] === \",\" ||code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || code[0].length === 0)){\n            // missing operands after the VISIBLE KEYWORD\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }else if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || code[0].length === 0 || (tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n            break;\n        }else if(code[0].join(\" \").trim().split(\" \")[0] === \"!\"){\n            // no new line encountered\n            code[0] = code[0].join(\" \").trim().split(\" \");\n            tableOfLexemes.push({value:code[0].shift(),description:\"No newline output\"});\n            continue;\n        }else if(tableOfLexemes[tableOfLexemes.length-1].value === \"!\" && code.length !== 0){\n            // if there is operation after ! beside inline comment\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// input abstraction //optimized\nconst input_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the GIMMEH KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    const error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable initialization //optimized\nconst initialization_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the ITZ KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(code[0][0] === \"A\" ){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable declaration //okay\nconst declaration_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the I HAS A KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error   \n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\" ?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Variable Identifier\";\n    // if special IT identifier\n    if(tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\" ?tableOfLexemes.length-2:tableOfLexemes.length-1].value === \"IT\"){\n        return `Syntax Error in line ${lineNumber}: ${tableOfLexemes.pop().value} is a Special Identifier.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\" && code[0][0] === \"ITZ\"){\n        // initialization\n        error = initialization_var_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable assignment //okay\nconst assignment_var_abs = (code,tableOfLexemes,lineNumber)=>{\n    let placeholder;\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }else if(code[0][0] === \"R\"){\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});  \n    }else{\n        // if inproper use of R\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    if(code[0].length === 0){\n        // missing operands after the R KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(code[0][0] === \"MAEK\"){\n        //operands\n        error = typecast_expr_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// arithmetic recursion //okay\nconst arithmetic_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i,error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    for (i = 0; i < 3; i++){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if(i !== 1){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            // if inproper use of AN\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// boolean operations op abstraction  //okay\nconst boolean_operands_abs = (code, tableOfLexemes, lineNumber, type) => {\n    let error, isChanged = true;\n    if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Boolean\"){\n        // boolean operations\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = boolean_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(code[0][0] === \"NOT\"){\n        // not operations\n        error = boolean_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(type && code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Boolean Many\"){\n        // boolean many operations\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = boolean_many_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(keywords[code[0][0]] && keywords[code[0][0]][0] === 'Comparison'){\n        // comparison different\n        error = comparison_abs(code,tableOfLexemes,lineNumber);\n    }else if(code[0][1]===\"SAEM\" && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Comparison\")){\n        // comparison same\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = comparison_abs(code,tableOfLexemes,lineNumber);\n    }else{\n        isChanged = false;\n    }\n    if(isChanged){\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged];\n}\n\n// boolean recursion abstraction //optimized\nconst boolean_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i,error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(tableOfLexemes[tableOfLexemes.length - 1].value === \"NOT\"){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        for (i = 0; i < 3; i++){\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            if(i !== 1){\n                //operands\n                error = operands_abs(code,tableOfLexemes,lineNumber, true);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            }else{\n                // if inproper use of AN\n                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n            }\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// boolean many recursion abstraction //okay\nconst boolean_many_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error,cnt=0;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(code[0].length === 0 && [\"ANY OF\",\"AN\",\"ALL OF\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(cnt>=2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || (tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"))){\n            return `Syntax Error in line ${lineNumber}: Expecting MKAY after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if([\"ANY OF\",\"AN\",\"ALL OF\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            cnt ++;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else if(cnt>=2 && code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n            break;\n        }else{\n            if(cnt < 2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || (tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"))){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// comparison abstraction //okay\nconst comparison_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i, error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    for (i = 0; i < 3; i++){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if(i !== 1){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            // if inproper use of AN\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// expression abstraction //okay\nconst expression_abs = (code, tableOfLexemes, lineNumber, type) => {\n    let error,isChanged = true;\n    if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Arithmetic\")){\n        // arithmetic\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = arithmetic_recurse_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else if(type && keywords[code[0][0]] && keywords[code[0][0]][0] === 'Concat'){\n        // concat\n        error = concat_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Function Call\")){\n        // function call\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = function_call_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        // boolean operations\n        error = boolean_operands_abs(code,tableOfLexemes,lineNumber,type);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber,isChanged] = error;\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged]\n}\n\n// concatenation abstraction //okay\nconst concat_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error,cnt = 0;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(code[0].length === 0 && [\"AN\",\"SMOOSH\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            // lacking operand after AN\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(cnt>=2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || (tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"))){\n            break;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if([\"AN\",\"SMOOSH\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            cnt++;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else if(cnt>=2 && code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n            break;\n        }else{\n            if(cnt < 2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || (tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"))){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n} \n\n// if else abstraction //okay\nconst if_else_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let placeholder = code[0].shift(), if_active = false,else_active = false,end=false,error;\n    placeholder = placeholder.slice(0,placeholder.length-1);\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    tableOfLexemes.push({value:\"?\",description:'Control Flow Delimiter'});\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of Flow Control.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if (code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"YA RLY\" && !if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = [code[0].shift(),code[0].shift()].join(\" \");\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"MEBBE\" && if_active && !else_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operation after ${placeholder}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;   \n        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"NO WAI\" && if_active && !else_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = [code[0].shift(),code[0].shift()].join(\" \");\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            else_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"OIC\" && if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            error = statement_abs(code,tableOfLexemes,lineNumber,type);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description) && code[0][0] === 'OBTW'){\n            // multiline comment\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0].length !== 0 && !if_active){\n            // if there is no if\n            return `Syntax Error in line ${lineNumber}: Expected start of Flow Control: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// Switch Case Abstraction //optimized\nconst switch_case_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let placeholder = code[0].shift(),start_active = false,default_active = false,end =false,error,listOfOptions = [],indexConstant=0;\n    placeholder = placeholder.slice(0,placeholder.length-1);\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    tableOfLexemes.push({value:\"?\",description:'Control Flow Delimiter'});\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of Flow Control.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if(code[0][0] === \"OMG\" && !default_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operation after ${placeholder}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            indexConstant = tableOfLexemes.length;\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            if(!tableOfLexemes[indexConstant].description.split(\" \").includes(\"Literal\")){\n                return `Syntax Error in line ${lineNumber}: Expected Constant Value at ${tableOfLexemes[indexConstant].value}.`;\n            }else if(listOfOptions.includes(tableOfLexemes[indexConstant].value)){\n                return `Syntax Error in line ${lineNumber}: OMG Literal Must be Unique at ${tableOfLexemes[indexConstant].value}.`;\n            }\n            listOfOptions.push(tableOfLexemes[indexConstant].value);\n            start_active = true;   \n        }else if(code[0][0] === \"OMGWTF\" && start_active && !default_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            default_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"OIC\" && start_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if((start_active || default_active) && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            error = statement_abs(code,tableOfLexemes,lineNumber,type===\"Function\"? type:\"Block Operations\");\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description) && code[0][0] === 'OBTW'){\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0].length !== 0 && !start_active){\n            return `Syntax Error in line ${lineNumber}: Expected start of Flow Control: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// loop abstraction //okay\nconst loop_abs = (code, tableOfLexemes, lineNumber,type) => {\n    let placeholder = code[0].shift(),error,end=false,loopName='';\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // for the name of the loop with the YR before\n    if(code[0][0] === \"YR\"){\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        // identifier\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n        loopName = tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].value;\n        tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Loop Identifier\";\n        if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        // increment or decrement with the UPPIN and the NERFIN\n        if(code[0][0] === \"UPPIN\" | code[0][0] === \"NERFIN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}es[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            // variable to be incremented with YR before\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                // identifier\n                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n                tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Parameter Identifier\";\n                if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                    return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                // the conditionals in the loop\n                if(code[0][0] === \"TIL\" | code[0][0] === \"WILE\"){\n                    placeholder = code[0].shift();\n                    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                    if(code[0].length === 0){\n                        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                    }\n                    if(code[0][0] === \"\"){\n                        // if there is exceeding whitespace in between the operation\n                        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                    }\n                    // the condition\n                    //operands\n                    error = operands_abs(code,tableOfLexemes,lineNumber, true);\n                    // check if error\n                    if(!Array.isArray(error)) return error;\n                    [code,tableOfLexemes, lineNumber] = error;\n                    // body of the loop\n                    while(!end){\n                        if(code.length === 0){\n                            return `Syntax Error in line ${lineNumber-1}: Expected End of the Loop.`;\n                        }\n                        if(code[0].length === 0){\n                            // encounter new line\n                            code.shift();\n                            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n                            }\n                            lineNumber++;\n                            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n                            if(code.length !== 0){\n                                code[0]=code[0].trim().split(\" \");\n                                if(code[0][0] === ''){\n                                    code[0].shift();\n                                    continue;\n                                }\n                                error = tokenizer_abs(code,lineNumber);\n                                if(!Array.isArray(error)) return error;\n                                [code, lineNumber] = error;\n                            }\n                            continue;\n                        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IM OUTTA\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n                            // loop code delimiter\n                            placeholder = [code[0].shift(),code[0].shift()].join(' ');\n                            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                            if(code[0].length === 0){\n                                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                            }\n                            if(code[0][0] === \"\"){\n                                // if there is exceeding whitespace in between the operation\n                                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                            }\n                            // name of the loop after the YR\n                            if(code[0][0] === \"YR\"){\n                                placeholder = code[0].shift();\n                                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                                if(code[0].length === 0){\n                                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                                }\n                                if(code[0][0] === \"\"){\n                                    // if there is exceeding whitespace in between the operation\n                                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                                }\n                                // identifier\n                                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                                // check if error\n                                if(!Array.isArray(error)) return error;\n                                [code,tableOfLexemes, lineNumber] = error;\n                                if (loopName !== tableOfLexemes[tableOfLexemes.length-1].value){\n                                    return `Syntax Error in line ${lineNumber}: Mismatched Loop Label.`;\n                                }\n                            }else{\n                                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n                            }\n                            end = true\n                        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n                            // body of the loop\n                            error = statement_abs(code,tableOfLexemes,lineNumber,type===\"Function\"? type:\"Block Operations\");\n                            if(!Array.isArray(error)) return error;\n                            [code,tableOfLexemes, lineNumber] = error;\n                        }\n                        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n                            // inline comment\n                            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n                        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n                            // if there is operation after the identifier\n                            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n                        }\n                    }\n                }else{\n                    return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n                }\n            }else{\n                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n            }\n        }else{\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }else{\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// function  abstraction //okay\nconst function_abs = (code, tableOfLexemes, lineNumber) => {\n    let placeholder = code[0].shift(),error,end=false;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Function Identifier\";\n    while(true){\n        if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }\n        if(code[0][0] === \"\" && ![\"BTW\",\",\"].includes(code[0].join(\" \").trim().split(\" \")[0])){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }else if(['Operand Delimiter Keyword','Function Identifier'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // identifier\n                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n                tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Parameter Identifier\";\n            }else{\n                if(tableOfLexemes[tableOfLexemes.length-1].value === \"AN\"){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }else{\n                    break;\n                }\n            }\n        }else if(code[0][0] === \"AN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            break;\n        }\n    }\n    // body of the function\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of the Function.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if(code[0][3] && [code[0][0],code[0][1],code[0][2],code[0][3]].join(\" \") === \"IF U SAY SO\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // loop code delimiter\n            placeholder = [code[0].shift(),code[0].shift(),code[0].shift(),code[0].shift()].join(' ');\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                code[0].shift()\n                tableOfLexemes.push({value:\",\",description:\"Command Line Break\"});\n            }\n            end = true\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // body of the loop\n            error = statement_abs(code,tableOfLexemes,lineNumber, 'Function');\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// function call abstraction //okay\nconst function_call_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Function Identifier\";\n    while(true){\n        if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }\n        if(code[0][0] === \"\" && ![\"BTW\",\",\"].includes(code[0].join(\" \").trim().split(\" \")[0])){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }else if(['Operand Delimiter Keyword','Function Identifier'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // operands\n                error = operands_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }else{\n                if(tableOfLexemes[tableOfLexemes.length-1].value === \"AN\"){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }else{\n                    if(code[0][0] === \"MKAY\"){\n                        placeholder = code[0].shift();\n                        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                    }\n                    break;\n                }\n            }\n        }else if(code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            break;\n        }else if(code[0][0] === \"AN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            break;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// statement abstraction //okay\nconst statement_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let error,isChanged = true;\n    let placeholder;\n    [code,tableOfLexemes, lineNumber, isChanged] = literal_abs(code,tableOfLexemes,lineNumber);\n    if(!isChanged){\n        error = expression_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber, isChanged] = error;\n    }\n    if(!isChanged){\n        isChanged = true;\n        if(code[0][0] === \"BTW\"){\n            error = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"OBTW\"){\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"VISIBLE\"){\n            error = output_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"GIMMEH\"){\n            error = input_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][1] && code[0][2] && keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")] && (keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")][0] === \"Declare Var\")){\n            code[0].unshift([code[0].shift(),code[0].shift(),code[0].shift()].join(\" \"));\n            error = declaration_var_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].includes(\"R\")){\n            error = assignment_var_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][1] && keywords[[code[0][0],code[0][1].slice(0,code[0][1].length-1)].join(\" \")] && (keywords[[code[0][0],code[0][1].slice(0,code[0][1].length-1)].join(\" \")][0] === \"If-Else\")){\n            code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n            error = if_else_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Loop\")){\n            code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n            error = loop_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][2] && keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")] && (keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")][0] === \"Function\")){\n            code[0].unshift([code[0].shift(),code[0].shift(),code[0].shift()].join(\" \"));\n            error = function_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"WTF?\"){\n            error = switch_case_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][0] === \"MAEK\"){\n            error = typecast_expr_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].join(' ').includes(\"IS NOW\")){\n            error = typecast_var_abs(code,tableOfLexemes,lineNumber);\n        }else if([\"TLDR\",\"OIC\"].includes(code[0][0])){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Flow-Control Structure: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][3] && [code[0][0],code[0][1],code[0][2],code[0][3]].join(\" \") === \"IF U SAY SO\"){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Function Structure: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IM OUTTA\"){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Loop Structure: ${code[0].join(\" \").trim()}.`;\n        }else{\n            isChanged = false;\n        }\n        if(isChanged){\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            if(code.length === 0){\n                return [code,tableOfLexemes, lineNumber];\n            }\n        }\n    }\n    if(!isChanged && (type === \"Function\" || type === \"Block Operations\")){\n        isChanged = true;\n        if(type === \"Function\" && code[0][0] === \"FOUND\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // loop code delimiter\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // return value\n                error = operands_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }\n        }else if(code[0][0] === \"GTFO\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // break code delimiter\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                code[0].shift()\n                tableOfLexemes.push({value:\",\",description:\"Command Line Break\"});\n            }\n        }else{\n            isChanged = false;\n        }\n    }\n    if(!isChanged){\n        // identifier\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;      \n    }\n    if(code[0].length !== 0){\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber]; \n}\n\n// type casting of expression //okay\nconst typecast_expr_abs = (code, tableOfLexemes, lineNumber) =>{\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    //operands\n    error = operands_abs(code,tableOfLexemes,lineNumber, true);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    // typecasting to data type\n    if(code[0][0] === \"A\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// type casting of var //okay\nconst typecast_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder;\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IS NOW\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n        placeholder = [code[0].shift(),code[0].shift()].join(' ');\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});  \n    }else{\n        // if inproper use of IS NOW\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    // typecasting to data type\n    if(code[0][0] === \"A\" ){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n\n    }else{\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length - 1].value}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// type initialization abstraction //okay\nconst type_init_abs = (code, tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(types[code[0][0]]){\n        // data types\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:types[placeholder][1]});\n        // if command line break encountered\n        if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n            code[0] = code[0].join(\" \").trim().split(\" \");\n            tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n        }\n    }else{\n        return `Syntax Error in line ${lineNumber}: Expected Data Type`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// yarn tokenizer and joiner abs\nconst tokenizer_abs = (code,lineNumber) => {\n    let index1,index2,tempHolder = [];\n    while(true){\n        index1 = code[0].findIndex((word)=>literal[\"YARN1\"][0].test(word));\n        if(index1 === -1) break;\n        index2 = code[0].findIndex((word,index)=>(literal[\"YARN2\"][0].test(word) && index !== index1));\n        if(index2>-1){\n            code[0][index1] = code[0].slice(index1,index2+1).join(\" \");\n            code[0] = code[0].slice(0,index1+1).concat(code[0].slice(index2+1,code[0].length));\n        }else{\n            // if lacking closing \"\n            return `Syntax Error in line ${lineNumber}: Unexpected Sequence: ${code[0].slice(index1,code[0].length).join(\" \").trim()}.`;\n        }\n    }\n    code[0].map((item)=>{\n        if(item[0] === '\\\"' && item[item.length-1] === '\\\"'){\n            tempHolder.push(item);\n        }else{\n            let temp_array = item.replace(/[\\,]/g, \" \\,\").replace(/[\\!]/g, \" \\!\").trim().replace(/[\\!](?=[^\\ ])/g, \"\\! \").replace(/[\\,](?=[^\\ ])/g, \"\\, \").trim().split(\" \");\n            if(item[0] === '\\\"'){\n                const index1 = temp_array.findIndex((word)=>literal[\"YARN1\"][0].test(word));\n                if(index1 !== -1){\n                    const index2 = temp_array.findIndex((word,index)=>(literal[\"YARN2\"][0].test(word) && index !== index1));\n                    if(index1 !== -1){\n                        temp_array[index1] = temp_array.slice(index1,index2+1).join(\" \");\n                        temp_array = temp_array.slice(0,index1+1).concat(temp_array.slice(index2+1,temp_array.length));\n                    }\n                }\n            }\n            tempHolder.push(...temp_array);\n        }\n        return item;\n      })\n    code[0] = tempHolder;\n    return [code,lineNumber];\n}\n\n// start program \nexport const program_abs = (code,tableOfLexemes,lineNumber) =>{\n    let start = false, end = false,placeholder,error;\n    code = code.split(\"\\n\");\n    while(code.length !==0){\n        if(!Array.isArray(code[0])){\n            // new line of code encountered\n            code[0] = code[0].trim().split(\" \");\n            // when there is no content in the line\n            if(code[0][0] === ''){\n                code[0].shift();\n                continue;\n            }\n            //tokenizer\n            error = tokenizer_abs(code,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code, lineNumber] = error;\n            continue;\n        }else if(code[0].length === 0){\n            console.log(code[0]);\n            // if new line encountered\n            code.shift();\n            console.log(code);\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            continue;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n            continue;\n        }else if((!start || (end && tableOfLexemes.length!==0 && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description))) && code[0][0] === 'OBTW'){\n            // multiline comment\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            continue;\n        }\n        if(!start && code[0][0] === \"HAI\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            start = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(start && !end && code[0][0] === \"KTHXBYE\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(start && !end){\n            // main body of the program\n            error = statement_abs(code,tableOfLexemes,lineNumber,'None');\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(start && code[0].length !== 0){\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }else{\n            return `Syntax Error in line ${lineNumber}: Expected start of the program.`;\n        }\n    }\n    if(!end && start){\n        return `Syntax Error in line ${lineNumber}: Expected end of the program.`;\n    }\n    return [code,tableOfLexemes, lineNumber]; \n}","/home/xera/web-projects/LOLCODE_Project/src/reportWebVitals.js",[],"/home/xera/web-projects/LOLCODE_Project/src/main/App.js",[],"/home/xera/web-projects/LOLCODE_Project/src/page/AppRouter.js",[],"/home/xera/web-projects/LOLCODE_Project/src/page/index.js",[],"/home/xera/web-projects/LOLCODE_Project/src/page/TitlePage.js",[],"/home/xera/web-projects/LOLCODE_Project/src/page/Interpreter.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/index.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/firstFrame.js",["131"],"import React, { useState, useEffect } from 'react';\nimport { Upload } from 'antd';\nimport AceEditor from 'react-ace';\nimport 'antd/dist/antd.css';\nimport '../main/App.css';\nimport \"ace-builds/src-noconflict/theme-github\";\n\nexport const FirstFrame = ({ lolText, setLolText}) => {\n  // Dragger is the file uploader above\n  const [localLolText,setLocalLolText] = useState('');\n  const { Dragger } = Upload;\n  const [files, setfiles] = useState([]);\n  const [fileProperty] = useState(\n    {\n      name: 'file',\n      multiple: false,\n      accept : \".lol\",\n      beforeUpload(file){\n        readFile(file);\n        return false;\n      },\n      onChange(info){\n        handleChange(info);\n      }\n    }\n  );\n\n// This Part handle changes in the file (i.e if a file is added)\nconst handleChange = (info) => {\n  setfiles([...info.fileList].slice(-1));\n}\n\n// This part catches the file that is uploaded/dragged to the Upload field\nconst readFile = async(file) => {\n    setLocalLolText(await file.text());\n}\n\n// If the button is clicked we set the main lol text which signals the second frame to parse the data\nuseEffect(() => {\n  setLolText(localLolText)\n},[localLolText])\n\n  return (\n    <div className=\"firstFrame\">\n        <Dragger className=\"dragBox\" {...fileProperty} fileList = {files} showUploadList={false}>\n          <p style={{color:'white'}}>Drag Your LOL Code File Here</p>\n        </Dragger>\n        <AceEditor mode={\"null\"} theme={\"github\"} width={\"100%\"} height={\"100%\"} showPrintMargin={false} placeholder={\"BTW Your code goes here\"} value = {localLolText} onChange ={(value)=>{setLocalLolText(value)}}/>\n    </div>\n  )\n}\n","/home/xera/web-projects/LOLCODE_Project/src/components/secondFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/fourthFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/thirdFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/fifthFrame.js",["132"],"import React, { useState, useRef, useEffect } from 'react'\nimport TextArea from 'antd/lib/input/TextArea'\n\nexport const FifthFrame = ({ lolText, symbolTable, setSymbolTable, parsedLol, setParsedLol, program_start, program_abs, buttonClick, setButtonClick }) => {\n    // This will keep track of the output key words i.e VISIBLE\n    // this is used to keep track of the values of prefixText\n    const prefixTextRef = useRef('')\n    const [prefixText,setPrefixText] = useState('');\n\n    // Handles the changes for the prefixText\n    const handlePrefixChanges = (strings) => {\n        prefixTextRef.current = prefixTextRef.current.concat(strings)\n        // setPrefixText(prefixTextRef.current)\n    }\n\n    useEffect(() => {\n        if(buttonClick){\n            const parsed_table = program_abs(lolText,[],1);\n            if(Array.isArray(parsed_table)){\n                prefixTextRef.current = \"\";\n                setParsedLol(parsed_table[1]);\n                const symbol_table = program_start([...parsed_table[1]],handlePrefixChanges);\n                if(Array.isArray(symbol_table)){\n                    setSymbolTable(symbol_table);\n                }else{\n                    prefixTextRef.current = symbol_table;\n                    setParsedLol([]);\n                    setSymbolTable([]);\n                }\n            }else{\n                prefixTextRef.current = parsed_table;\n                setParsedLol([]);\n                setSymbolTable([]);\n            }\n            setPrefixText(prefixTextRef.current);\n            setButtonClick(false);\n        }\n    },[buttonClick])\n\n    return (\n        <div className = \"fifthFrame\">\n        <TextArea className=\"fifthFrameTerminal\" bordered={false} value={prefixText} readOnly></TextArea>\n        </div>\n    )\n}\n",{"ruleId":"133","replacedBy":"134"},{"ruleId":"135","replacedBy":"136"},{"ruleId":"137","severity":1,"message":"138","line":11,"column":3,"nodeType":"139","messageId":"140","endLine":19,"endColumn":4},{"ruleId":"141","severity":1,"message":"142","line":84,"column":4,"nodeType":"143","messageId":"144","endLine":84,"endColumn":39},{"ruleId":"145","severity":1,"message":"146","line":326,"column":23,"nodeType":"147","messageId":"148","endLine":326,"endColumn":24,"suggestions":"149"},{"ruleId":"145","severity":1,"message":"146","line":327,"column":19,"nodeType":"147","messageId":"148","endLine":327,"endColumn":20,"suggestions":"150"},{"ruleId":"145","severity":1,"message":"151","line":327,"column":21,"nodeType":"147","messageId":"148","endLine":327,"endColumn":22,"suggestions":"152"},{"ruleId":"145","severity":1,"message":"146","line":328,"column":20,"nodeType":"147","messageId":"148","endLine":328,"endColumn":21,"suggestions":"153"},{"ruleId":"145","severity":1,"message":"154","line":328,"column":22,"nodeType":"147","messageId":"148","endLine":328,"endColumn":23,"suggestions":"155"},{"ruleId":"145","severity":1,"message":"146","line":329,"column":27,"nodeType":"147","messageId":"148","endLine":329,"endColumn":28,"suggestions":"156"},{"ruleId":"145","severity":1,"message":"157","line":329,"column":29,"nodeType":"147","messageId":"148","endLine":329,"endColumn":30,"suggestions":"158"},{"ruleId":"145","severity":1,"message":"146","line":330,"column":21,"nodeType":"147","messageId":"148","endLine":330,"endColumn":22,"suggestions":"159"},{"ruleId":"145","severity":1,"message":"146","line":330,"column":23,"nodeType":"147","messageId":"148","endLine":330,"endColumn":24,"suggestions":"160"},{"ruleId":"145","severity":1,"message":"146","line":331,"column":24,"nodeType":"147","messageId":"148","endLine":331,"endColumn":25,"suggestions":"161"},{"ruleId":"145","severity":1,"message":"146","line":332,"column":21,"nodeType":"147","messageId":"148","endLine":332,"endColumn":22,"suggestions":"162"},{"ruleId":"145","severity":1,"message":"146","line":332,"column":25,"nodeType":"147","messageId":"148","endLine":332,"endColumn":26,"suggestions":"163"},{"ruleId":"145","severity":1,"message":"164","line":364,"column":33,"nodeType":"147","messageId":"148","endLine":364,"endColumn":34,"suggestions":"165"},{"ruleId":"145","severity":1,"message":"146","line":368,"column":34,"nodeType":"147","messageId":"148","endLine":368,"endColumn":35,"suggestions":"166"},{"ruleId":"137","severity":1,"message":"138","line":588,"column":3,"nodeType":"139","messageId":"140","endLine":610,"endColumn":4},{"ruleId":"141","severity":1,"message":"142","line":626,"column":4,"nodeType":"143","messageId":"144","endLine":626,"endColumn":22},{"ruleId":"141","severity":1,"message":"142","line":707,"column":4,"nodeType":"143","messageId":"144","endLine":707,"endColumn":34},{"ruleId":"137","severity":1,"message":"138","line":763,"column":3,"nodeType":"139","messageId":"140","endLine":794,"endColumn":4},{"ruleId":"141","severity":1,"message":"142","line":766,"column":4,"nodeType":"143","messageId":"144","endLine":766,"endColumn":30},{"ruleId":"167","severity":1,"message":"168","line":825,"column":6,"nodeType":"169","messageId":"170","endLine":825,"endColumn":11},{"ruleId":"141","severity":1,"message":"142","line":926,"column":4,"nodeType":"143","messageId":"144","endLine":926,"endColumn":37},{"ruleId":"141","severity":1,"message":"142","line":1044,"column":4,"nodeType":"143","messageId":"144","endLine":1044,"endColumn":42},{"ruleId":"141","severity":1,"message":"142","line":1135,"column":4,"nodeType":"143","messageId":"144","endLine":1135,"endColumn":37},{"ruleId":"145","severity":1,"message":"171","line":62,"column":17,"nodeType":"147","messageId":"148","endLine":62,"endColumn":18,"suggestions":"172"},{"ruleId":"145","severity":1,"message":"171","line":63,"column":18,"nodeType":"147","messageId":"148","endLine":63,"endColumn":19,"suggestions":"173"},{"ruleId":"145","severity":1,"message":"174","line":64,"column":18,"nodeType":"147","messageId":"148","endLine":64,"endColumn":19,"suggestions":"175"},{"ruleId":"145","severity":1,"message":"174","line":64,"column":24,"nodeType":"147","messageId":"148","endLine":64,"endColumn":25,"suggestions":"176"},{"ruleId":"145","severity":1,"message":"146","line":64,"column":29,"nodeType":"147","messageId":"148","endLine":64,"endColumn":30,"suggestions":"177"},{"ruleId":"145","severity":1,"message":"174","line":64,"column":31,"nodeType":"147","messageId":"148","endLine":64,"endColumn":32,"suggestions":"178"},{"ruleId":"145","severity":1,"message":"174","line":65,"column":20,"nodeType":"147","messageId":"148","endLine":65,"endColumn":21,"suggestions":"179"},{"ruleId":"145","severity":1,"message":"146","line":65,"column":25,"nodeType":"147","messageId":"148","endLine":65,"endColumn":26,"suggestions":"180"},{"ruleId":"145","severity":1,"message":"174","line":65,"column":27,"nodeType":"147","messageId":"148","endLine":65,"endColumn":28,"suggestions":"181"},{"ruleId":"145","severity":1,"message":"174","line":65,"column":33,"nodeType":"147","messageId":"148","endLine":65,"endColumn":34,"suggestions":"182"},{"ruleId":"145","severity":1,"message":"183","line":65,"column":37,"nodeType":"147","messageId":"148","endLine":65,"endColumn":38,"suggestions":"184"},{"ruleId":"145","severity":1,"message":"185","line":65,"column":39,"nodeType":"147","messageId":"148","endLine":65,"endColumn":40,"suggestions":"186"},{"ruleId":"145","severity":1,"message":"174","line":66,"column":17,"nodeType":"147","messageId":"148","endLine":66,"endColumn":18,"suggestions":"187"},{"ruleId":"145","severity":1,"message":"174","line":66,"column":23,"nodeType":"147","messageId":"148","endLine":66,"endColumn":24,"suggestions":"188"},{"ruleId":"145","severity":1,"message":"146","line":66,"column":28,"nodeType":"147","messageId":"148","endLine":66,"endColumn":29,"suggestions":"189"},{"ruleId":"145","severity":1,"message":"174","line":66,"column":30,"nodeType":"147","messageId":"148","endLine":66,"endColumn":31,"suggestions":"190"},{"ruleId":"145","severity":1,"message":"174","line":66,"column":36,"nodeType":"147","messageId":"148","endLine":66,"endColumn":37,"suggestions":"191"},{"ruleId":"145","severity":1,"message":"192","line":70,"column":44,"nodeType":"147","messageId":"148","endLine":70,"endColumn":45,"suggestions":"193"},{"ruleId":"194","severity":1,"message":"195","line":1278,"column":36,"nodeType":"196","messageId":"197","endLine":1278,"endColumn":102},{"ruleId":"145","severity":1,"message":"174","line":1288,"column":25,"nodeType":"147","messageId":"148","endLine":1288,"endColumn":26,"suggestions":"198"},{"ruleId":"145","severity":1,"message":"174","line":1288,"column":57,"nodeType":"147","messageId":"148","endLine":1288,"endColumn":58,"suggestions":"199"},{"ruleId":"145","severity":1,"message":"185","line":1291,"column":45,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":46,"suggestions":"200"},{"ruleId":"145","severity":1,"message":"185","line":1291,"column":54,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":55,"suggestions":"201"},{"ruleId":"145","severity":1,"message":"183","line":1291,"column":69,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":70,"suggestions":"202"},{"ruleId":"145","severity":1,"message":"183","line":1291,"column":78,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":79,"suggestions":"203"},{"ruleId":"145","severity":1,"message":"183","line":1291,"column":100,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":101,"suggestions":"204"},{"ruleId":"145","severity":1,"message":"205","line":1291,"column":108,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":109,"suggestions":"206"},{"ruleId":"145","severity":1,"message":"183","line":1291,"column":117,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":118,"suggestions":"207"},{"ruleId":"145","severity":1,"message":"185","line":1291,"column":133,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":134,"suggestions":"208"},{"ruleId":"145","severity":1,"message":"205","line":1291,"column":141,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":142,"suggestions":"209"},{"ruleId":"145","severity":1,"message":"185","line":1291,"column":150,"nodeType":"147","messageId":"148","endLine":1291,"endColumn":151,"suggestions":"210"},{"ruleId":"145","severity":1,"message":"174","line":1292,"column":29,"nodeType":"147","messageId":"148","endLine":1292,"endColumn":30,"suggestions":"211"},{"ruleId":"212","severity":1,"message":"213","line":41,"column":3,"nodeType":"214","endLine":41,"endColumn":17,"suggestions":"215"},{"ruleId":"212","severity":1,"message":"216","line":38,"column":7,"nodeType":"214","endLine":38,"endColumn":20,"suggestions":"217"},"no-native-reassign",["218"],"no-negated-in-lhs",["219"],"default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-fallthrough","Expected a 'break' statement before 'case'.","SwitchCase","case","no-useless-escape","Unnecessary escape character: \\:.","Literal","unnecessaryEscape",["220","221"],["222","223"],"Unnecessary escape character: \\>.",["224","225"],["226","227"],"Unnecessary escape character: \\o.",["228","229"],["230","231"],"Unnecessary escape character: \\'.",["232","233"],["234","235"],["236","237"],["238","239"],["240","241"],["242","243"],"Unnecessary escape character: \\g.",["244","245"],["246","247"],"no-unused-vars","'error' is defined but never used.","Identifier","unusedVar","Unnecessary escape character: \\-.",["248","249"],["250","251"],"Unnecessary escape character: \\\".",["252","253"],["254","255"],["256","257"],["258","259"],["260","261"],["262","263"],["264","265"],["266","267"],"Unnecessary escape character: \\!.",["268","269"],"Unnecessary escape character: \\,.",["270","271"],["272","273"],["274","275"],["276","277"],["278","279"],["280","281"],"Unnecessary escape character: \\_.",["282","283"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'index1'.","ArrowFunctionExpression","unsafeRefs",["284","285"],["286","287"],["288","289"],["290","291"],["292","293"],["294","295"],["296","297"],"Unnecessary escape character: \\ .",["298","299"],["300","301"],["302","303"],["304","305"],["306","307"],["308","309"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setLolText'. Either include it or remove the dependency array. If 'setLolText' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["310"],"React Hook useEffect has missing dependencies: 'lolText', 'program_abs', 'program_start', 'setButtonClick', 'setParsedLol', and 'setSymbolTable'. Either include them or remove the dependency array. If 'program_abs' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["311"],"no-global-assign","no-unsafe-negation",{"messageId":"312","fix":"313","desc":"314"},{"messageId":"315","fix":"316","desc":"317"},{"messageId":"312","fix":"318","desc":"314"},{"messageId":"315","fix":"319","desc":"317"},{"messageId":"312","fix":"320","desc":"314"},{"messageId":"315","fix":"321","desc":"317"},{"messageId":"312","fix":"322","desc":"314"},{"messageId":"315","fix":"323","desc":"317"},{"messageId":"312","fix":"324","desc":"314"},{"messageId":"315","fix":"325","desc":"317"},{"messageId":"312","fix":"326","desc":"314"},{"messageId":"315","fix":"327","desc":"317"},{"messageId":"312","fix":"328","desc":"314"},{"messageId":"315","fix":"329","desc":"317"},{"messageId":"312","fix":"330","desc":"314"},{"messageId":"315","fix":"331","desc":"317"},{"messageId":"312","fix":"332","desc":"314"},{"messageId":"315","fix":"333","desc":"317"},{"messageId":"312","fix":"334","desc":"314"},{"messageId":"315","fix":"335","desc":"317"},{"messageId":"312","fix":"336","desc":"314"},{"messageId":"315","fix":"337","desc":"317"},{"messageId":"312","fix":"338","desc":"314"},{"messageId":"315","fix":"339","desc":"317"},{"messageId":"312","fix":"340","desc":"314"},{"messageId":"315","fix":"341","desc":"317"},{"messageId":"312","fix":"342","desc":"314"},{"messageId":"315","fix":"343","desc":"317"},{"messageId":"312","fix":"344","desc":"314"},{"messageId":"315","fix":"345","desc":"317"},{"messageId":"312","fix":"346","desc":"314"},{"messageId":"315","fix":"347","desc":"317"},{"messageId":"312","fix":"348","desc":"314"},{"messageId":"315","fix":"349","desc":"317"},{"messageId":"312","fix":"350","desc":"314"},{"messageId":"315","fix":"351","desc":"317"},{"messageId":"312","fix":"352","desc":"314"},{"messageId":"315","fix":"353","desc":"317"},{"messageId":"312","fix":"354","desc":"314"},{"messageId":"315","fix":"355","desc":"317"},{"messageId":"312","fix":"356","desc":"314"},{"messageId":"315","fix":"357","desc":"317"},{"messageId":"312","fix":"358","desc":"314"},{"messageId":"315","fix":"359","desc":"317"},{"messageId":"312","fix":"360","desc":"314"},{"messageId":"315","fix":"361","desc":"317"},{"messageId":"312","fix":"362","desc":"314"},{"messageId":"315","fix":"363","desc":"317"},{"messageId":"312","fix":"364","desc":"314"},{"messageId":"315","fix":"365","desc":"317"},{"messageId":"312","fix":"366","desc":"314"},{"messageId":"315","fix":"367","desc":"317"},{"messageId":"312","fix":"368","desc":"314"},{"messageId":"315","fix":"369","desc":"317"},{"messageId":"312","fix":"370","desc":"314"},{"messageId":"315","fix":"371","desc":"317"},{"messageId":"312","fix":"372","desc":"314"},{"messageId":"315","fix":"373","desc":"317"},{"messageId":"312","fix":"374","desc":"314"},{"messageId":"315","fix":"375","desc":"317"},{"messageId":"312","fix":"376","desc":"314"},{"messageId":"315","fix":"377","desc":"317"},{"messageId":"312","fix":"378","desc":"314"},{"messageId":"315","fix":"379","desc":"317"},{"messageId":"312","fix":"380","desc":"314"},{"messageId":"315","fix":"381","desc":"317"},{"messageId":"312","fix":"382","desc":"314"},{"messageId":"315","fix":"383","desc":"317"},{"messageId":"312","fix":"384","desc":"314"},{"messageId":"315","fix":"385","desc":"317"},{"messageId":"312","fix":"386","desc":"314"},{"messageId":"315","fix":"387","desc":"317"},{"messageId":"312","fix":"388","desc":"314"},{"messageId":"315","fix":"389","desc":"317"},{"messageId":"312","fix":"390","desc":"314"},{"messageId":"315","fix":"391","desc":"317"},{"messageId":"312","fix":"392","desc":"314"},{"messageId":"315","fix":"393","desc":"317"},{"messageId":"312","fix":"394","desc":"314"},{"messageId":"315","fix":"395","desc":"317"},{"messageId":"312","fix":"396","desc":"314"},{"messageId":"315","fix":"397","desc":"317"},{"messageId":"312","fix":"398","desc":"314"},{"messageId":"315","fix":"399","desc":"317"},{"messageId":"312","fix":"400","desc":"314"},{"messageId":"315","fix":"401","desc":"317"},{"messageId":"312","fix":"402","desc":"314"},{"messageId":"315","fix":"403","desc":"317"},{"messageId":"312","fix":"404","desc":"314"},{"messageId":"315","fix":"405","desc":"317"},{"desc":"406","fix":"407"},{"desc":"408","fix":"409"},"removeEscape",{"range":"410","text":"411"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"412","text":"413"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"414","text":"411"},{"range":"415","text":"413"},{"range":"416","text":"411"},{"range":"417","text":"413"},{"range":"418","text":"411"},{"range":"419","text":"413"},{"range":"420","text":"411"},{"range":"421","text":"413"},{"range":"422","text":"411"},{"range":"423","text":"413"},{"range":"424","text":"411"},{"range":"425","text":"413"},{"range":"426","text":"411"},{"range":"427","text":"413"},{"range":"428","text":"411"},{"range":"429","text":"413"},{"range":"430","text":"411"},{"range":"431","text":"413"},{"range":"432","text":"411"},{"range":"433","text":"413"},{"range":"434","text":"411"},{"range":"435","text":"413"},{"range":"436","text":"411"},{"range":"437","text":"413"},{"range":"438","text":"411"},{"range":"439","text":"413"},{"range":"440","text":"411"},{"range":"441","text":"413"},{"range":"442","text":"411"},{"range":"443","text":"413"},{"range":"444","text":"411"},{"range":"445","text":"413"},{"range":"446","text":"411"},{"range":"447","text":"413"},{"range":"448","text":"411"},{"range":"449","text":"413"},{"range":"450","text":"411"},{"range":"451","text":"413"},{"range":"452","text":"411"},{"range":"453","text":"413"},{"range":"454","text":"411"},{"range":"455","text":"413"},{"range":"456","text":"411"},{"range":"457","text":"413"},{"range":"458","text":"411"},{"range":"459","text":"413"},{"range":"460","text":"411"},{"range":"461","text":"413"},{"range":"462","text":"411"},{"range":"463","text":"413"},{"range":"464","text":"411"},{"range":"465","text":"413"},{"range":"466","text":"411"},{"range":"467","text":"413"},{"range":"468","text":"411"},{"range":"469","text":"413"},{"range":"470","text":"411"},{"range":"471","text":"413"},{"range":"472","text":"411"},{"range":"473","text":"413"},{"range":"474","text":"411"},{"range":"475","text":"413"},{"range":"476","text":"411"},{"range":"477","text":"413"},{"range":"478","text":"411"},{"range":"479","text":"413"},{"range":"480","text":"411"},{"range":"481","text":"413"},{"range":"482","text":"411"},{"range":"483","text":"413"},{"range":"484","text":"411"},{"range":"485","text":"413"},{"range":"486","text":"411"},{"range":"487","text":"413"},{"range":"488","text":"411"},{"range":"489","text":"413"},{"range":"490","text":"411"},{"range":"491","text":"413"},{"range":"492","text":"411"},{"range":"493","text":"413"},{"range":"494","text":"411"},{"range":"495","text":"413"},{"range":"496","text":"411"},{"range":"497","text":"413"},{"range":"498","text":"411"},{"range":"499","text":"413"},{"range":"500","text":"411"},{"range":"501","text":"413"},"Update the dependencies array to be: [localLolText, setLolText]",{"range":"502","text":"503"},"Update the dependencies array to be: [buttonClick, lolText, program_abs, program_start, setButtonClick, setParsedLol, setSymbolTable]",{"range":"504","text":"505"},[10833,10834],"",[10833,10833],"\\",[10859,10860],[10859,10859],[10861,10862],[10861,10861],[10886,10887],[10886,10886],[10888,10889],[10888,10888],[10920,10921],[10920,10920],[10922,10923],[10922,10922],[10948,10949],[10948,10948],[10950,10951],[10950,10950],[10979,10980],[10979,10979],[11028,11029],[11028,11028],[11032,11033],[11032,11032],[12165,12166],[12165,12165],[12405,12406],[12405,12405],[3230,3231],[3230,3230],[3278,3279],[3278,3278],[3335,3336],[3335,3335],[3341,3342],[3341,3341],[3346,3347],[3346,3346],[3348,3349],[3348,3348],[3393,3394],[3393,3393],[3398,3399],[3398,3398],[3400,3401],[3400,3400],[3406,3407],[3406,3406],[3410,3411],[3410,3410],[3412,3413],[3412,3412],[3457,3458],[3457,3457],[3463,3464],[3463,3463],[3468,3469],[3468,3468],[3470,3471],[3470,3470],[3476,3477],[3476,3476],[3596,3597],[3596,3596],[69094,69095],[69094,69094],[69126,69127],[69126,69126],[69226,69227],[69226,69226],[69235,69236],[69235,69235],[69250,69251],[69250,69250],[69259,69260],[69259,69259],[69281,69282],[69281,69281],[69289,69290],[69289,69289],[69298,69299],[69298,69298],[69314,69315],[69314,69314],[69322,69323],[69322,69322],[69331,69332],[69331,69331],[69384,69385],[69384,69384],[1148,1162],"[localLolText, setLolText]",[1569,1582],"[buttonClick, lolText, program_abs, program_start, setButtonClick, setParsedLol, setSymbolTable]"]