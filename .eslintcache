[{"/home/xera/web-projects/LOLCODE_Project/src/index.js":"1","/home/xera/web-projects/LOLCODE_Project/src/utils/semantics.js":"2","/home/xera/web-projects/LOLCODE_Project/src/utils/lexemes.js":"3","/home/xera/web-projects/LOLCODE_Project/src/utils/parser.js":"4","/home/xera/web-projects/LOLCODE_Project/src/main/App.js":"5","/home/xera/web-projects/LOLCODE_Project/src/reportWebVitals.js":"6","/home/xera/web-projects/LOLCODE_Project/src/components/firstFrame.js":"7","/home/xera/web-projects/LOLCODE_Project/src/components/fourthFrame.js":"8","/home/xera/web-projects/LOLCODE_Project/src/components/thirdFrame.js":"9","/home/xera/web-projects/LOLCODE_Project/src/components/fifthFrame.js":"10","/home/xera/web-projects/LOLCODE_Project/src/components/secondFrame.js":"11","/home/xera/web-projects/LOLCODE_Project/src/components/index.js":"12"},{"size":505,"mtime":1609384691270,"results":"13","hashOfConfig":"14"},{"size":40762,"mtime":1609398220880,"results":"15","hashOfConfig":"14"},{"size":3820,"mtime":1609386699850,"results":"16","hashOfConfig":"14"},{"size":73675,"mtime":1609402578780,"results":"17","hashOfConfig":"14"},{"size":1619,"mtime":1609401082150,"results":"18","hashOfConfig":"14"},{"size":362,"mtime":1609384707470,"results":"19","hashOfConfig":"14"},{"size":1629,"mtime":1609402011060,"results":"20","hashOfConfig":"14"},{"size":314,"mtime":1609401992780,"results":"21","hashOfConfig":"14"},{"size":974,"mtime":1609401985550,"results":"22","hashOfConfig":"14"},{"size":1766,"mtime":1609402634960,"results":"23","hashOfConfig":"14"},{"size":1321,"mtime":1609402032170,"results":"24","hashOfConfig":"14"},{"size":151,"mtime":1609385553550,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"mwyusg",{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"31","messages":"32","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/home/xera/web-projects/LOLCODE_Project/src/index.js",[],["53","54"],"/home/xera/web-projects/LOLCODE_Project/src/utils/semantics.js",["55"],"/home/xera/web-projects/LOLCODE_Project/src/utils/lexemes.js",["56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73"],"export const keywords = \n    {\n        \"HAI\":['Start','Code Delimiter Keyword'],\n        \"KTHXBYE\":['End','Code Delimiter Keyword'],\n        \"BTW\":['Comment','Line Comment Keyword'],\n        \"OBTW\":['Multi-Line Comment Start','Comment Delimiter Keyword'],\n        \"TLDR\":['Multi-Line Comment End','Comment Delimiter Keyword'],\n        \"I HAS A\":['Declare Var','Variable Declaration Keyword'],\n        \"ITZ\":['Initialize Var','Variable Initialization Keyword'],\n        \"R\":['Assigment Var','Variable Assignment Keyword'],\n        \"SUM OF\":['Arithmetic','Addition Operation Keyword'],\n        \"DIFF OF\":['Arithmetic','Subtraction Operation Keyword'],\n        \"PRODUKT OF\":['Arithmetic','Multiplication Operation Keyword'],\n        \"QUOSHUNT OF\":['Arithmetic','Division Operation Keyword'],\n        \"MOD OF\":['Arithmetic','Modulo Operation Keyword'],\n        \"BIGGR OF\":['Arithmetic','Max Operation Keyword'],\n        \"SMALLR OF\":['Arithmetic','Min Operation Keyword'],\n        \"BOTH OF\":['Boolean','AND Operation Keyword'],\n        \"EITHER OF\":['Boolean','OR Operation Keyword'],\n        \"WON OF\":['Boolean','XOR Operation Keyword'],\n        \"NOT\":['Boolean','NOT Operation Keyword'],\n        \"ANY OF\":['Boolean Many','OR Delimiter Operation Keyword'],\n        \"ALL OF\":['Boolean Many','AND Delimiter Operation Keyword'],\n        \"BOTH SAEM\":['Comparison','Equal Operation Keyword'],\n        \"DIFFRINT\":['Comparison','Not Equal Operation Keyword'],\n        \"SMOOSH\":['Concat','Concatenation Operation Keyword'],\n        \"MAEK\":['Declare Typecast','Type Casting Declaration Keyword'],\n        \"IS NOW\":['Initialize Typecast','Type Casting Initialization Keyword'],\n        \"A\":['Type Keyword','Type Keyword'],\n        \"VISIBLE\":['Output','Output Keyword'],\n        \"GIMMEH\":['Input','Input Keyword'],\n        \"O RLY\":['If-Else','If-Else Delimiter Keyword'],\n        \"YA RLY\":['If','If Keyword'],\n        \"MEBBE\":['Else-If','Else-If Keyword'],\n        \"NO WAI\":['Else','Else Keyword'],\n        \"OIC\":['Flow-Control End','Flow-Control Delimiter Keyword'],\n        \"WTF\":['Switch','Switch Case Delimiter Keyword'],\n        \"OMG\":['Switch Option','Case Keyword'],\n        \"OMGWTF\":['Switch Default','Case-Default Keyword'],\n        \"GTFO\":['Break','Break Keyword'],\n        \"IM IN\":['Loop','Loop Delimiter Keyword'],\n        \"YR\":['Delimiter','Parameter Delimiter Keyword'],\n        \"UPPIN\":['Loop Inc','Increment Keyword'],\n        \"NERFIN\":['Loop Dec','Decrement Keyword'],\n        \"TIL\":['Loop Cond','Loop Keyword'],\n        \"WILE\":['Loop Cond','Loop Keyword'],\n        \"IM OUTTA\":['Loop End','Loop Delimiter Keyword'],\n        \"AN\":['Conjunction','Operand Delimiter Keyword'],\n        \"HOW IZ I\":['Function', 'Function Delimeter Keyword'],\n        \"IF U SAY SO\":['Function End', 'Function Delimeter Keyword'],\n        \"FOUND\": ['Function Return','Function Return Keyword'],\n        \"I IZ\":['Function Call', 'Function Call Keyword'],\n        \"NUMBR\":['Type','NUMBR Type Keyword'],\n        \"NUMBAR\":['Type','NUMBAR Type Keyword'],\n        \"YARN\":['Type','YARN Type Keyword'],\n        \"TROOF\":['Type','TROOF Type Keyword'],\n        \"MKAY\":['Boolean Many','Infinite Delimiter Keyword'],\n    }\n\n\nexport const literal = {\n    \"NUMBR\":[/(^\\-?[0-9]+$)/,'NUMBR Literal'],\n    \"NUMBAR\":[/(^\\-?[0-9]*\\.[0-9]+$)/,'NUMBAR Literal'],\n    \"YARN1\":[/(^[\\\"]([^\\\"]|(\\:\\\"))*$)/,'YARN Literal'],\n    \"YARN2\":[/(^([^\\\"]|(\\:\\\"))*[\\\"][\\!\\,]{0,2}$)/,'YARN Literal'],\n    \"YARN\":[/(^[\\\"]([^\\\"]|(\\:\\\"))*[\\\"]$)/,'YARN Literal'],\n    \"TROOF\":[/^((WIN)|(FAIL))$/,'TROOF Literal'],\n}\n\nexport const identifier = [/^([A-Za-z]+[0-9\\_]*)$/,'Identifier']\n\nexport const types = {\n    \"NUMBR\":['Type','NUMBR Type'],\n    \"NUMBAR\":['Type','NUMBAR Type'],\n    \"YARN\":['Type','YARN Type'],\n    \"TROOF\":['Type','TROOF Type'],\n    \"NOOB\" : ['Type','NOOB Type'],\n}\n\n","/home/xera/web-projects/LOLCODE_Project/src/utils/parser.js",["74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97"],"import { keywords , literal ,identifier, types} from './lexemes';\n\n// inline comment abstraction //okay\nconst inline_comment_abs = (code, tableOfLexemes,lineNumber)=>{\n    code[0] = code[0].join(\" \").trim().split(\" \");\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    // if there is comment after BTW\n    if(code[0].length !== 0){\n        placeholder = code[0].join(\" \");\n        tableOfLexemes.push({value:placeholder,description:'Comment'});\n        code[0] = [];\n    }\n    return [code, tableOfLexemes, lineNumber];\n}\n\n// multiline comment abstraction //okay\nconst multiline_comment_abs = (code, tableOfLexemes, lineNumber) =>{\n    let placeholder = code[0].shift(),error,indexTLDR;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    // getting all the comment before the line of TLDR\n    while(!code[0].includes('TLDR')){\n        placeholder = code.shift().join(\" \").trim();\n        if(placeholder !== \"\"){\n            tableOfLexemes.push({value:placeholder,description:'Comment'});\n        }\n        tableOfLexemes.push({value:'\\n',description:'Line Break'});\n        // if there is no TLDR present in the code\n        if(code.length === 0) return `Syntax Error in line ${lineNumber}: Expected end of Multi-Line Comment.`;\n        code[0]=code[0].trim().split(\" \");\n        error = tokenizer_abs(code,lineNumber);\n        if(!Array.isArray(error)) return error;\n        [code, lineNumber] = error;\n        lineNumber++;\n    }\n    indexTLDR = code[0].indexOf(\"TLDR\");\n    // if there is comment before TLDR\n    if(indexTLDR !== 0){\n        placeholder = code[0].slice(0,indexTLDR).join(\" \").trim();\n        tableOfLexemes.push({value:placeholder,description:'Comment'});\n    }\n    tableOfLexemes.push({value:'TLDR',description:keywords['TLDR'][1]});\n    code[0] = code[0].slice(indexTLDR+1,code[0].length).join(\" \").trim().split(\" \");\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }if(code[0][0] === '' && code[0].length ===1){\n        code[0].shift();\n    }\n    return [code, tableOfLexemes, lineNumber];\n}\n\n// literal abstraction //okay\nconst literal_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),isChanged = true;\n    if(literal[\"NUMBAR\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"NUMBAR\"][1]});\n    }else if(literal[\"NUMBR\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"NUMBR\"][1]});\n    }else if(literal[\"YARN\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"YARN\"][1]});\n    }else if(literal[\"TROOF\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"TROOF\"][1]});\n    }else{\n        code[0].unshift(placeholder);\n        isChanged = false;\n    }\n    // if command line break encountered\n    if(isChanged && code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged];\n}\n\n// identifier abstraction //okay\nconst identifier_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    if(placeholder[0] === '\\'' &&  placeholder[placeholder.length-1] === '\\''){\n        // if there are string that were enclose by single quotes\n        return `Syntax Error in line ${lineNumber}: Unexpected Sequence: ${placeholder}.`;\n    }else if(keywords[placeholder] || [\"WIN\",\"FAIL\"].includes(placeholder) || !identifier[0].test(placeholder)){\n        // invalid format of the identifier\n        return `Syntax Error in line ${lineNumber}: Expected Identifier: ${placeholder}.`;\n    }else{\n        tableOfLexemes.push({value:placeholder, description: identifier[1]});\n    }\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// operands abstraction //okay\nconst operands_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let error,isChanged;\n    // literal\n    [code,tableOfLexemes, lineNumber, isChanged] = literal_abs(code,tableOfLexemes,lineNumber);\n    // expression\n    if(!isChanged){\n        error = expression_abs(code,tableOfLexemes,lineNumber,type);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber, isChanged] = error;\n    }\n    // identifier\n    if(!isChanged){\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// output abstraction //okay\nconst output_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift() , error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(tableOfLexemes[tableOfLexemes.length-1].value === \"VISIBLE\" && (code[0].join(\" \").trim().split(\" \")[0] === \",\" ||code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || code[0].length === 0)){\n            // missing operands after the VISIBLE KEYWORD\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }else if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || code[0].length === 0 || tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }else if(code[0].join(\" \").trim().split(\" \")[0] === \"!\"){\n            // no new line encountered\n            code[0] = code[0].join(\" \").trim().split(\" \");\n            tableOfLexemes.push({value:code[0].shift(),description:\"No newline output\"});\n            continue;\n        }else if(tableOfLexemes[tableOfLexemes.length-1].value === \"!\" && code.length !== 0){\n            // if there is operation after ! beside inline comment\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// input abstraction //optimized\nconst input_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the GIMMEH KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    const error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable initialization //optimized\nconst initialization_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the ITZ KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(code[0][0] === \"A\" ){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable declaration //okay\nconst declaration_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the I HAS A KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error   \n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\" ?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Variable Identifier\";\n    // if special IT identifier\n    if(tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\" ?tableOfLexemes.length-2:tableOfLexemes.length-1].value === \"IT\"){\n        return `Syntax Error in line ${lineNumber}: ${tableOfLexemes.pop().value} is a Special Identifier.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\" && code[0][0] === \"ITZ\"){\n        // initialization\n        error = initialization_var_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable assignment //okay\nconst assignment_var_abs = (code,tableOfLexemes,lineNumber)=>{\n    let placeholder;\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }else if(code[0][0] === \"R\"){\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});  \n    }else{\n        // if inproper use of R\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    if(code[0].length === 0){\n        // missing operands after the R KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(code[0][0] === \"MAEK\"){\n        //operands\n        error = typecast_expr_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// arithmetic recursion //okay\nconst arithmetic_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i,error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    for (i = 0; i < 3; i++){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if(i !== 1){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            // if inproper use of AN\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// boolean operations op abstraction  //okay\nconst boolean_operands_abs = (code, tableOfLexemes, lineNumber, type) => {\n    let error, isChanged = true;\n    if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Boolean\"){\n        // boolean operations\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = boolean_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(code[0][0] === \"NOT\"){\n        // not operations\n        error = boolean_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(type && code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Boolean Many\"){\n        // boolean many operations\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = boolean_many_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(keywords[code[0][0]] && keywords[code[0][0]][0] === 'Comparison'){\n        // comparison different\n        error = comparison_abs(code,tableOfLexemes,lineNumber);\n    }else if(code[0][1]===\"SAEM\" && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Comparison\")){\n        // comparison same\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = comparison_abs(code,tableOfLexemes,lineNumber);\n    }else{\n        isChanged = false;\n    }\n    if(isChanged){\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged];\n}\n\n// boolean recursion abstraction //optimized\nconst boolean_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i,error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(tableOfLexemes[tableOfLexemes.length - 1].value === \"NOT\"){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        for (i = 0; i < 3; i++){\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            if(i !== 1){\n                //operands\n                error = operands_abs(code,tableOfLexemes,lineNumber, true);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            }else{\n                // if inproper use of AN\n                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n            }\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// boolean many recursion abstraction //okay\nconst boolean_many_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error,cnt=0;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(code[0].length === 0 && [\"ANY OF\",\"AN\",\"ALL OF\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(cnt>=2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n            return `Syntax Error in line ${lineNumber}: Expecting MKAY after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if([\"ANY OF\",\"AN\",\"ALL OF\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            cnt ++;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else if(cnt>=2 && code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n            break;\n        }else{\n            if(cnt < 2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// comparison abstraction //okay\nconst comparison_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i, error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    for (i = 0; i < 3; i++){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if(i !== 1){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            // if inproper use of AN\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// expression abstraction //okay\nconst expression_abs = (code, tableOfLexemes, lineNumber, type) => {\n    let error,isChanged = true;\n    if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Arithmetic\")){\n        // arithmetic\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = arithmetic_recurse_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else if(type && keywords[code[0][0]] && keywords[code[0][0]][0] === 'Concat'){\n        // concat\n        error = concat_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Function Call\")){\n        // function call\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = function_call_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        // boolean operations\n        error = boolean_operands_abs(code,tableOfLexemes,lineNumber,type);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber,isChanged] = error;\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged]\n}\n\n// concatenation abstraction //okay\nconst concat_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error,cnt = 0;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(code[0].length === 0 && [\"AN\",\"SMOOSH\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            // lacking operand after AN\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(cnt>=2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n            break;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if([\"AN\",\"SMOOSH\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            cnt++;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else if(cnt>=2 && code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n            break;\n        }else{\n            if(cnt < 2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n} \n\n// if else abstraction //okay\nconst if_else_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let placeholder = code[0].shift(), if_active = false,else_active = false,end=false,error;\n    placeholder = placeholder.slice(0,placeholder.length-1);\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    tableOfLexemes.push({value:\"?\",description:'Control Flow Delimiter'});\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of Flow Control.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if (code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"YA RLY\" && !if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = [code[0].shift(),code[0].shift()].join(\" \");\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"MEBBE\" && if_active && !else_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operation after ${placeholder}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;   \n        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"NO WAI\" && if_active && !else_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = [code[0].shift(),code[0].shift()].join(\" \");\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            else_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"OIC\" && if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            error = statement_abs(code,tableOfLexemes,lineNumber,type);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description) && code[0][0] === 'OBTW'){\n            // multiline comment\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0].length !== 0 && !if_active){\n            // if there is no if\n            return `Syntax Error in line ${lineNumber}: Expected start of Flow Control: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// Switch Case Abstraction //optimized\nconst switch_case_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let placeholder = code[0].shift(),start_active = false,default_active = false,end =false,error,listOfOptions = [],indexConstant=0;\n    placeholder = placeholder.slice(0,placeholder.length-1);\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    tableOfLexemes.push({value:\"?\",description:'Control Flow Delimiter'});\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of Flow Control.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if(code[0][0] === \"OMG\" && !default_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operation after ${placeholder}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            indexConstant = tableOfLexemes.length;\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            if(!tableOfLexemes[indexConstant].description.split(\" \").includes(\"Literal\")){\n                return `Syntax Error in line ${lineNumber}: Expected Constant Value at ${tableOfLexemes[indexConstant].value}.`;\n            }else if(listOfOptions.includes(tableOfLexemes[indexConstant].value)){\n                return `Syntax Error in line ${lineNumber}: OMG Literal Must be Unique at ${tableOfLexemes[indexConstant].value}.`;\n            }\n            listOfOptions.push(tableOfLexemes[indexConstant].value);\n            start_active = true;   \n        }else if(code[0][0] === \"OMGWTF\" && start_active && !default_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            default_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"OIC\" && start_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if((start_active || default_active) && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            error = statement_abs(code,tableOfLexemes,lineNumber,type===\"Function\"? type:\"Block Operations\");\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description) && code[0][0] === 'OBTW'){\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0].length !== 0 && !start_active){\n            return `Syntax Error in line ${lineNumber}: Expected start of Flow Control: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// loop abstraction //okay\nconst loop_abs = (code, tableOfLexemes, lineNumber,type) => {\n    let placeholder = code[0].shift(),error,end=false,loopName='';\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // for the name of the loop with the YR before\n    if(code[0][0] === \"YR\"){\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        // identifier\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n        loopName = tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].value;\n        tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Loop Identifier\";\n        if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        // increment or decrement with the UPPIN and the NERFIN\n        if(code[0][0] === \"UPPIN\" | code[0][0] === \"NERFIN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}es[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            // variable to be incremented with YR before\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                // identifier\n                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n                tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Parameter Identifier\";\n                if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                    return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                // the conditionals in the loop\n                if(code[0][0] === \"TIL\" | code[0][0] === \"WILE\"){\n                    placeholder = code[0].shift();\n                    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                    if(code[0].length === 0){\n                        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                    }\n                    if(code[0][0] === \"\"){\n                        // if there is exceeding whitespace in between the operation\n                        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                    }\n                    // the condition\n                    //operands\n                    error = operands_abs(code,tableOfLexemes,lineNumber, true);\n                    // check if error\n                    if(!Array.isArray(error)) return error;\n                    [code,tableOfLexemes, lineNumber] = error;\n                    // body of the loop\n                    while(!end){\n                        if(code.length === 0){\n                            return `Syntax Error in line ${lineNumber-1}: Expected End of the Loop.`;\n                        }\n                        if(code[0].length === 0){\n                            // encounter new line\n                            code.shift();\n                            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n                            }\n                            lineNumber++;\n                            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n                            if(code.length !== 0){\n                                code[0]=code[0].trim().split(\" \");\n                                if(code[0][0] === ''){\n                                    code[0].shift();\n                                    continue;\n                                }\n                                error = tokenizer_abs(code,lineNumber);\n                                if(!Array.isArray(error)) return error;\n                                [code, lineNumber] = error;\n                            }\n                            continue;\n                        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IM OUTTA\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n                            // loop code delimiter\n                            placeholder = [code[0].shift(),code[0].shift()].join(' ');\n                            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                            if(code[0].length === 0){\n                                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                            }\n                            if(code[0][0] === \"\"){\n                                // if there is exceeding whitespace in between the operation\n                                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                            }\n                            // name of the loop after the YR\n                            if(code[0][0] === \"YR\"){\n                                placeholder = code[0].shift();\n                                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                                if(code[0].length === 0){\n                                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                                }\n                                if(code[0][0] === \"\"){\n                                    // if there is exceeding whitespace in between the operation\n                                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                                }\n                                // identifier\n                                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                                // check if error\n                                if(!Array.isArray(error)) return error;\n                                [code,tableOfLexemes, lineNumber] = error;\n                                if (loopName !== tableOfLexemes[tableOfLexemes.length-1].value){\n                                    return `Syntax Error in line ${lineNumber}: Mismatched Loop Label.`;\n                                }\n                            }else{\n                                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n                            }\n                            end = true\n                        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n                            // body of the loop\n                            error = statement_abs(code,tableOfLexemes,lineNumber,type===\"Function\"? type:\"Block Operations\");\n                            if(!Array.isArray(error)) return error;\n                            [code,tableOfLexemes, lineNumber] = error;\n                        }\n                        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n                            // inline comment\n                            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n                        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n                            // if there is operation after the identifier\n                            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n                        }\n                    }\n                }else{\n                    return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n                }\n            }else{\n                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n            }\n        }else{\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }else{\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// function  abstraction //okay\nconst function_abs = (code, tableOfLexemes, lineNumber) => {\n    let placeholder = code[0].shift(),error,end=false;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Function Identifier\";\n    while(true){\n        if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }\n        if(code[0][0] === \"\" && ![\"BTW\",\",\"].includes(code[0].join(\" \").trim().split(\" \")[0])){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }else if(['Operand Delimiter Keyword','Function Identifier'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // identifier\n                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n                tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Parameter Identifier\";\n            }else{\n                if(tableOfLexemes[tableOfLexemes.length-1].value === \"AN\"){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }else{\n                    break;\n                }\n            }\n        }else if(code[0][0] === \"AN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            break;\n        }\n    }\n    // body of the function\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of the Function.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if(code[0][3] && [code[0][0],code[0][1],code[0][2],code[0][3]].join(\" \") === \"IF U SAY SO\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // loop code delimiter\n            placeholder = [code[0].shift(),code[0].shift(),code[0].shift(),code[0].shift()].join(' ');\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                code[0].shift()\n                tableOfLexemes.push({value:\",\",description:\"Command Line Break\"});\n            }\n            end = true\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // body of the loop\n            error = statement_abs(code,tableOfLexemes,lineNumber, 'Function');\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// function call abstraction //okay\nconst function_call_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Function Identifier\";\n    while(true){\n        if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }\n        if(code[0][0] === \"\" && ![\"BTW\",\",\"].includes(code[0].join(\" \").trim().split(\" \")[0])){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }else if(['Operand Delimiter Keyword','Function Identifier'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // operands\n                error = operands_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }else{\n                if(tableOfLexemes[tableOfLexemes.length-1].value === \"AN\"){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }else{\n                    if(code[0][0] === \"MKAY\"){\n                        placeholder = code[0].shift();\n                        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                    }\n                    break;\n                }\n            }\n        }else if(code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            break;\n        }else if(code[0][0] === \"AN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            break;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// statement abstraction //okay\nconst statement_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let error,isChanged = true;\n    let placeholder;\n    [code,tableOfLexemes, lineNumber, isChanged] = literal_abs(code,tableOfLexemes,lineNumber);\n    if(!isChanged){\n        error = expression_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber, isChanged] = error;\n    }\n    if(!isChanged){\n        isChanged = true;\n        if(code[0][0] === \"BTW\"){\n            error = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"OBTW\"){\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"VISIBLE\"){\n            error = output_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"GIMMEH\"){\n            error = input_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][1] && code[0][2] && keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")] && (keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")][0] === \"Declare Var\")){\n            code[0].unshift([code[0].shift(),code[0].shift(),code[0].shift()].join(\" \"));\n            error = declaration_var_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].includes(\"R\")){\n            error = assignment_var_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][1] && keywords[[code[0][0],code[0][1].slice(0,code[0][1].length-1)].join(\" \")] && (keywords[[code[0][0],code[0][1].slice(0,code[0][1].length-1)].join(\" \")][0] === \"If-Else\")){\n            code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n            error = if_else_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Loop\")){\n            code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n            error = loop_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][2] && keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")] && (keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")][0] === \"Function\")){\n            code[0].unshift([code[0].shift(),code[0].shift(),code[0].shift()].join(\" \"));\n            error = function_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"WTF?\"){\n            error = switch_case_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][0] === \"MAEK\"){\n            error = typecast_expr_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].join(' ').includes(\"IS NOW\")){\n            error = typecast_var_abs(code,tableOfLexemes,lineNumber);\n        }else if([\"TLDR\",\"OIC\"].includes(code[0][0])){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Flow-Control Structure: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][3] && [code[0][0],code[0][1],code[0][2],code[0][3]].join(\" \") === \"IF U SAY SO\"){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Function Structure: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IM OUTTA\"){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Loop Structure: ${code[0].join(\" \").trim()}.`;\n        }else{\n            isChanged = false;\n        }\n        if(isChanged){\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            if(code.length === 0){\n                return [code,tableOfLexemes, lineNumber];\n            }\n        }\n    }\n    if(!isChanged && (type === \"Function\" || type === \"Block Operations\")){\n        isChanged = true;\n        if(type === \"Function\" && code[0][0] === \"FOUND\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // loop code delimiter\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // return value\n                error = operands_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }\n        }else if(code[0][0] === \"GTFO\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // break code delimiter\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                code[0].shift()\n                tableOfLexemes.push({value:\",\",description:\"Command Line Break\"});\n            }\n        }else{\n            isChanged = false;\n        }\n    }\n    if(!isChanged){\n        // identifier\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;      \n    }\n    if(code[0].length !== 0){\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber]; \n}\n\n// type casting of expression //okay\nconst typecast_expr_abs = (code, tableOfLexemes, lineNumber) =>{\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    //operands\n    error = operands_abs(code,tableOfLexemes,lineNumber, true);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    // typecasting to data type\n    if(code[0][0] === \"A\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// type casting of var //okay\nconst typecast_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder;\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IS NOW\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n        placeholder = [code[0].shift(),code[0].shift()].join(' ');\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});  \n    }else{\n        // if inproper use of IS NOW\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    // typecasting to data type\n    if(code[0][0] === \"A\" ){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n\n    }else{\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length - 1].value}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// type initialization abstraction //okay\nconst type_init_abs = (code, tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(types[code[0][0]]){\n        // data types\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:types[placeholder][1]});\n        // if command line break encountered\n        if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n            code[0] = code[0].join(\" \").trim().split(\" \");\n            tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n        }\n    }else{\n        return `Syntax Error in line ${lineNumber}: Expected Data Type`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// yarn tokenizer and joiner abs\nconst tokenizer_abs = (code,lineNumber) => {\n    let index1,index2,tempHolder = [];\n    while(true){\n        index1 = code[0].findIndex((word)=>literal[\"YARN1\"][0].test(word));\n        if(index1 === -1) break;\n        index2 = code[0].findIndex((word,index)=>(literal[\"YARN2\"][0].test(word) && index !== index1));\n        if(index2>-1){\n            code[0][index1] = code[0].slice(index1,index2+1).join(\" \");\n            code[0] = code[0].slice(0,index1+1).concat(code[0].slice(index2+1,code[0].length));\n        }else{\n            // if lacking closing \"\n            return `Syntax Error in line ${lineNumber}: Unexpected Sequence: ${code[0].slice(index1,code[0].length).join(\" \").trim()}.`;\n        }\n    }\n    code[0].map((item)=>{\n        if(item[0] === '\\\"' && item[item.length-1] === '\\\"'){\n            tempHolder.push(item);\n        }else{\n            let temp_array = item.replace(/[\\,]/g, \" \\,\").replace(/[\\!]/g, \" \\!\").trim().replace(/[\\!](?=[^\\ ])/g, \"\\! \").replace(/[\\,](?=[^\\ ])/g, \"\\, \").trim().split(\" \");\n            if(item[0] === '\\\"'){\n                const index1 = temp_array.findIndex((word)=>literal[\"YARN1\"][0].test(word));\n                if(index1 !== -1){\n                    const index2 = temp_array.findIndex((word,index)=>(literal[\"YARN2\"][0].test(word) && index !== index1));\n                    if(index1 !== -1){\n                        temp_array[index1] = temp_array.slice(index1,index2+1).join(\" \");\n                        temp_array = temp_array.slice(0,index1+1).concat(temp_array.slice(index2+1,temp_array.length));\n                    }\n                }\n            }\n            tempHolder.push(...temp_array);\n        }\n        return item;\n      })\n    code[0] = tempHolder;\n    return [code,lineNumber];\n}\n\n// start program \nexport const program_abs = (code,tableOfLexemes,lineNumber) =>{\n    let start = false, end = false,placeholder,error;\n    code = code.split(\"\\n\");\n    while(code.length !==0){\n        if(!Array.isArray(code[0])){\n            // new line of code encountered\n            code[0] = code[0].trim().split(\" \");\n            // when there is no content in the line\n            if(code[0][0] === ''){\n                code[0].shift();\n                continue;\n            }\n            //tokenizer\n            error = tokenizer_abs(code,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code, lineNumber] = error;\n            continue;\n        }else if(code[0].length === 0){\n            console.log(code[0]);\n            // if new line encountered\n            code.shift();\n            console.log(code);\n            if(tableOfLexemes.length!==0 && tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            continue;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n            continue;\n        }else if((!start || (end && tableOfLexemes.length!==0 && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description))) && code[0][0] === 'OBTW'){\n            // multiline comment\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            continue;\n        }\n        if(!start && code[0][0] === \"HAI\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            start = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(start && !end && code[0][0] === \"KTHXBYE\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(start && !end){\n            // main body of the program\n            error = statement_abs(code,tableOfLexemes,lineNumber,'None');\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(start && code[0].length !== 0){\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }else{\n            return `Syntax Error in line ${lineNumber}: Expected start of the program.`;\n        }\n    }\n    if(!end && start){\n        return `Syntax Error in line ${lineNumber}: Expected end of the program.`;\n    }\n    return [code,tableOfLexemes, lineNumber]; \n}","/home/xera/web-projects/LOLCODE_Project/src/main/App.js",[],"/home/xera/web-projects/LOLCODE_Project/src/reportWebVitals.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/firstFrame.js",["98"],"/home/xera/web-projects/LOLCODE_Project/src/components/fourthFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/thirdFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/fifthFrame.js",["99"],"/home/xera/web-projects/LOLCODE_Project/src/components/secondFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/index.js",[],{"ruleId":"100","replacedBy":"101"},{"ruleId":"102","replacedBy":"103"},{"ruleId":"104","severity":1,"message":"105","line":824,"column":6,"nodeType":"106","messageId":"107","endLine":824,"endColumn":11},{"ruleId":"108","severity":1,"message":"109","line":62,"column":17,"nodeType":"110","messageId":"111","endLine":62,"endColumn":18,"suggestions":"112"},{"ruleId":"108","severity":1,"message":"109","line":63,"column":18,"nodeType":"110","messageId":"111","endLine":63,"endColumn":19,"suggestions":"113"},{"ruleId":"108","severity":1,"message":"114","line":64,"column":18,"nodeType":"110","messageId":"111","endLine":64,"endColumn":19,"suggestions":"115"},{"ruleId":"108","severity":1,"message":"114","line":64,"column":24,"nodeType":"110","messageId":"111","endLine":64,"endColumn":25,"suggestions":"116"},{"ruleId":"108","severity":1,"message":"117","line":64,"column":29,"nodeType":"110","messageId":"111","endLine":64,"endColumn":30,"suggestions":"118"},{"ruleId":"108","severity":1,"message":"114","line":64,"column":31,"nodeType":"110","messageId":"111","endLine":64,"endColumn":32,"suggestions":"119"},{"ruleId":"108","severity":1,"message":"114","line":65,"column":20,"nodeType":"110","messageId":"111","endLine":65,"endColumn":21,"suggestions":"120"},{"ruleId":"108","severity":1,"message":"117","line":65,"column":25,"nodeType":"110","messageId":"111","endLine":65,"endColumn":26,"suggestions":"121"},{"ruleId":"108","severity":1,"message":"114","line":65,"column":27,"nodeType":"110","messageId":"111","endLine":65,"endColumn":28,"suggestions":"122"},{"ruleId":"108","severity":1,"message":"114","line":65,"column":33,"nodeType":"110","messageId":"111","endLine":65,"endColumn":34,"suggestions":"123"},{"ruleId":"108","severity":1,"message":"124","line":65,"column":37,"nodeType":"110","messageId":"111","endLine":65,"endColumn":38,"suggestions":"125"},{"ruleId":"108","severity":1,"message":"126","line":65,"column":39,"nodeType":"110","messageId":"111","endLine":65,"endColumn":40,"suggestions":"127"},{"ruleId":"108","severity":1,"message":"114","line":66,"column":17,"nodeType":"110","messageId":"111","endLine":66,"endColumn":18,"suggestions":"128"},{"ruleId":"108","severity":1,"message":"114","line":66,"column":23,"nodeType":"110","messageId":"111","endLine":66,"endColumn":24,"suggestions":"129"},{"ruleId":"108","severity":1,"message":"117","line":66,"column":28,"nodeType":"110","messageId":"111","endLine":66,"endColumn":29,"suggestions":"130"},{"ruleId":"108","severity":1,"message":"114","line":66,"column":30,"nodeType":"110","messageId":"111","endLine":66,"endColumn":31,"suggestions":"131"},{"ruleId":"108","severity":1,"message":"114","line":66,"column":36,"nodeType":"110","messageId":"111","endLine":66,"endColumn":37,"suggestions":"132"},{"ruleId":"108","severity":1,"message":"133","line":70,"column":44,"nodeType":"110","messageId":"111","endLine":70,"endColumn":45,"suggestions":"134"},{"ruleId":"135","severity":1,"message":"136","line":127,"column":91,"nodeType":"137","messageId":"138","endLine":127,"endColumn":93},{"ruleId":"135","severity":1,"message":"136","line":127,"column":120,"nodeType":"137","messageId":"138","endLine":127,"endColumn":122},{"ruleId":"135","severity":1,"message":"136","line":392,"column":96,"nodeType":"137","messageId":"138","endLine":392,"endColumn":98},{"ruleId":"135","severity":1,"message":"136","line":392,"column":125,"nodeType":"137","messageId":"138","endLine":392,"endColumn":127},{"ruleId":"135","severity":1,"message":"136","line":419,"column":101,"nodeType":"137","messageId":"138","endLine":419,"endColumn":103},{"ruleId":"135","severity":1,"message":"136","line":419,"column":130,"nodeType":"137","messageId":"138","endLine":419,"endColumn":132},{"ruleId":"135","severity":1,"message":"136","line":499,"column":96,"nodeType":"137","messageId":"138","endLine":499,"endColumn":98},{"ruleId":"135","severity":1,"message":"136","line":499,"column":125,"nodeType":"137","messageId":"138","endLine":499,"endColumn":127},{"ruleId":"135","severity":1,"message":"136","line":526,"column":101,"nodeType":"137","messageId":"138","endLine":526,"endColumn":103},{"ruleId":"135","severity":1,"message":"136","line":526,"column":130,"nodeType":"137","messageId":"138","endLine":526,"endColumn":132},{"ruleId":"139","severity":1,"message":"140","line":1278,"column":36,"nodeType":"141","messageId":"142","endLine":1278,"endColumn":102},{"ruleId":"108","severity":1,"message":"114","line":1288,"column":25,"nodeType":"110","messageId":"111","endLine":1288,"endColumn":26,"suggestions":"143"},{"ruleId":"108","severity":1,"message":"114","line":1288,"column":57,"nodeType":"110","messageId":"111","endLine":1288,"endColumn":58,"suggestions":"144"},{"ruleId":"108","severity":1,"message":"126","line":1291,"column":45,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":46,"suggestions":"145"},{"ruleId":"108","severity":1,"message":"126","line":1291,"column":54,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":55,"suggestions":"146"},{"ruleId":"108","severity":1,"message":"124","line":1291,"column":69,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":70,"suggestions":"147"},{"ruleId":"108","severity":1,"message":"124","line":1291,"column":78,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":79,"suggestions":"148"},{"ruleId":"108","severity":1,"message":"124","line":1291,"column":100,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":101,"suggestions":"149"},{"ruleId":"108","severity":1,"message":"150","line":1291,"column":108,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":109,"suggestions":"151"},{"ruleId":"108","severity":1,"message":"124","line":1291,"column":117,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":118,"suggestions":"152"},{"ruleId":"108","severity":1,"message":"126","line":1291,"column":133,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":134,"suggestions":"153"},{"ruleId":"108","severity":1,"message":"150","line":1291,"column":141,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":142,"suggestions":"154"},{"ruleId":"108","severity":1,"message":"126","line":1291,"column":150,"nodeType":"110","messageId":"111","endLine":1291,"endColumn":151,"suggestions":"155"},{"ruleId":"108","severity":1,"message":"114","line":1292,"column":29,"nodeType":"110","messageId":"111","endLine":1292,"endColumn":30,"suggestions":"156"},{"ruleId":"157","severity":1,"message":"158","line":41,"column":3,"nodeType":"159","endLine":41,"endColumn":17,"suggestions":"160"},{"ruleId":"157","severity":1,"message":"161","line":38,"column":7,"nodeType":"159","endLine":38,"endColumn":20,"suggestions":"162"},"no-native-reassign",["163"],"no-negated-in-lhs",["164"],"no-unused-vars","'error' is defined but never used.","Identifier","unusedVar","no-useless-escape","Unnecessary escape character: \\-.","Literal","unnecessaryEscape",["165","166"],["167","168"],"Unnecessary escape character: \\\".",["169","170"],["171","172"],"Unnecessary escape character: \\:.",["173","174"],["175","176"],["177","178"],["179","180"],["181","182"],["183","184"],"Unnecessary escape character: \\!.",["185","186"],"Unnecessary escape character: \\,.",["187","188"],["189","190"],["191","192"],["193","194"],["195","196"],["197","198"],"Unnecessary escape character: \\_.",["199","200"],"no-mixed-operators","Unexpected mix of '||' and '&&'.","LogicalExpression","unexpectedMixedOperator","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'index1'.","ArrowFunctionExpression","unsafeRefs",["201","202"],["203","204"],["205","206"],["207","208"],["209","210"],["211","212"],["213","214"],"Unnecessary escape character: \\ .",["215","216"],["217","218"],["219","220"],["221","222"],["223","224"],["225","226"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setLolText'. Either include it or remove the dependency array. If 'setLolText' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["227"],"React Hook useEffect has missing dependencies: 'lolText', 'program_abs', 'program_start', 'setButtonClick', 'setParsedLol', and 'setSymbolTable'. Either include them or remove the dependency array. If 'program_abs' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["228"],"no-global-assign","no-unsafe-negation",{"messageId":"229","fix":"230","desc":"231"},{"messageId":"232","fix":"233","desc":"234"},{"messageId":"229","fix":"235","desc":"231"},{"messageId":"232","fix":"236","desc":"234"},{"messageId":"229","fix":"237","desc":"231"},{"messageId":"232","fix":"238","desc":"234"},{"messageId":"229","fix":"239","desc":"231"},{"messageId":"232","fix":"240","desc":"234"},{"messageId":"229","fix":"241","desc":"231"},{"messageId":"232","fix":"242","desc":"234"},{"messageId":"229","fix":"243","desc":"231"},{"messageId":"232","fix":"244","desc":"234"},{"messageId":"229","fix":"245","desc":"231"},{"messageId":"232","fix":"246","desc":"234"},{"messageId":"229","fix":"247","desc":"231"},{"messageId":"232","fix":"248","desc":"234"},{"messageId":"229","fix":"249","desc":"231"},{"messageId":"232","fix":"250","desc":"234"},{"messageId":"229","fix":"251","desc":"231"},{"messageId":"232","fix":"252","desc":"234"},{"messageId":"229","fix":"253","desc":"231"},{"messageId":"232","fix":"254","desc":"234"},{"messageId":"229","fix":"255","desc":"231"},{"messageId":"232","fix":"256","desc":"234"},{"messageId":"229","fix":"257","desc":"231"},{"messageId":"232","fix":"258","desc":"234"},{"messageId":"229","fix":"259","desc":"231"},{"messageId":"232","fix":"260","desc":"234"},{"messageId":"229","fix":"261","desc":"231"},{"messageId":"232","fix":"262","desc":"234"},{"messageId":"229","fix":"263","desc":"231"},{"messageId":"232","fix":"264","desc":"234"},{"messageId":"229","fix":"265","desc":"231"},{"messageId":"232","fix":"266","desc":"234"},{"messageId":"229","fix":"267","desc":"231"},{"messageId":"232","fix":"268","desc":"234"},{"messageId":"229","fix":"269","desc":"231"},{"messageId":"232","fix":"270","desc":"234"},{"messageId":"229","fix":"271","desc":"231"},{"messageId":"232","fix":"272","desc":"234"},{"messageId":"229","fix":"273","desc":"231"},{"messageId":"232","fix":"274","desc":"234"},{"messageId":"229","fix":"275","desc":"231"},{"messageId":"232","fix":"276","desc":"234"},{"messageId":"229","fix":"277","desc":"231"},{"messageId":"232","fix":"278","desc":"234"},{"messageId":"229","fix":"279","desc":"231"},{"messageId":"232","fix":"280","desc":"234"},{"messageId":"229","fix":"281","desc":"231"},{"messageId":"232","fix":"282","desc":"234"},{"messageId":"229","fix":"283","desc":"231"},{"messageId":"232","fix":"284","desc":"234"},{"messageId":"229","fix":"285","desc":"231"},{"messageId":"232","fix":"286","desc":"234"},{"messageId":"229","fix":"287","desc":"231"},{"messageId":"232","fix":"288","desc":"234"},{"messageId":"229","fix":"289","desc":"231"},{"messageId":"232","fix":"290","desc":"234"},{"messageId":"229","fix":"291","desc":"231"},{"messageId":"232","fix":"292","desc":"234"},{"messageId":"229","fix":"293","desc":"231"},{"messageId":"232","fix":"294","desc":"234"},{"desc":"295","fix":"296"},{"desc":"297","fix":"298"},"removeEscape",{"range":"299","text":"300"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"301","text":"302"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"303","text":"300"},{"range":"304","text":"302"},{"range":"305","text":"300"},{"range":"306","text":"302"},{"range":"307","text":"300"},{"range":"308","text":"302"},{"range":"309","text":"300"},{"range":"310","text":"302"},{"range":"311","text":"300"},{"range":"312","text":"302"},{"range":"313","text":"300"},{"range":"314","text":"302"},{"range":"315","text":"300"},{"range":"316","text":"302"},{"range":"317","text":"300"},{"range":"318","text":"302"},{"range":"319","text":"300"},{"range":"320","text":"302"},{"range":"321","text":"300"},{"range":"322","text":"302"},{"range":"323","text":"300"},{"range":"324","text":"302"},{"range":"325","text":"300"},{"range":"326","text":"302"},{"range":"327","text":"300"},{"range":"328","text":"302"},{"range":"329","text":"300"},{"range":"330","text":"302"},{"range":"331","text":"300"},{"range":"332","text":"302"},{"range":"333","text":"300"},{"range":"334","text":"302"},{"range":"335","text":"300"},{"range":"336","text":"302"},{"range":"337","text":"300"},{"range":"338","text":"302"},{"range":"339","text":"300"},{"range":"340","text":"302"},{"range":"341","text":"300"},{"range":"342","text":"302"},{"range":"343","text":"300"},{"range":"344","text":"302"},{"range":"345","text":"300"},{"range":"346","text":"302"},{"range":"347","text":"300"},{"range":"348","text":"302"},{"range":"349","text":"300"},{"range":"350","text":"302"},{"range":"351","text":"300"},{"range":"352","text":"302"},{"range":"353","text":"300"},{"range":"354","text":"302"},{"range":"355","text":"300"},{"range":"356","text":"302"},{"range":"357","text":"300"},{"range":"358","text":"302"},{"range":"359","text":"300"},{"range":"360","text":"302"},{"range":"361","text":"300"},{"range":"362","text":"302"},"Update the dependencies array to be: [localLolText, setLolText]",{"range":"363","text":"364"},"Update the dependencies array to be: [buttonClick, lolText, program_abs, program_start, setButtonClick, setParsedLol, setSymbolTable]",{"range":"365","text":"366"},[3230,3231],"",[3230,3230],"\\",[3278,3279],[3278,3278],[3335,3336],[3335,3335],[3341,3342],[3341,3341],[3346,3347],[3346,3346],[3348,3349],[3348,3348],[3393,3394],[3393,3393],[3398,3399],[3398,3398],[3400,3401],[3400,3400],[3406,3407],[3406,3406],[3410,3411],[3410,3410],[3412,3413],[3412,3412],[3457,3458],[3457,3457],[3463,3464],[3463,3463],[3468,3469],[3468,3468],[3470,3471],[3470,3470],[3476,3477],[3476,3476],[3596,3597],[3596,3596],[69084,69085],[69084,69084],[69116,69117],[69116,69116],[69216,69217],[69216,69216],[69225,69226],[69225,69225],[69240,69241],[69240,69240],[69249,69250],[69249,69249],[69271,69272],[69271,69271],[69279,69280],[69279,69279],[69288,69289],[69288,69288],[69304,69305],[69304,69304],[69312,69313],[69312,69312],[69321,69322],[69321,69321],[69374,69375],[69374,69374],[1148,1162],"[localLolText, setLolText]",[1569,1582],"[buttonClick, lolText, program_abs, program_start, setButtonClick, setParsedLol, setSymbolTable]"]