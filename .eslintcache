[{"/home/xera/web-projects/LOLCODE_Project/src/index.js":"1","/home/xera/web-projects/LOLCODE_Project/src/utils/semantics.js":"2","/home/xera/web-projects/LOLCODE_Project/src/utils/lexemes.js":"3","/home/xera/web-projects/LOLCODE_Project/src/utils/parser.js":"4","/home/xera/web-projects/LOLCODE_Project/src/main/App.js":"5","/home/xera/web-projects/LOLCODE_Project/src/reportWebVitals.js":"6","/home/xera/web-projects/LOLCODE_Project/src/components/firstFrame.js":"7","/home/xera/web-projects/LOLCODE_Project/src/components/fourthFrame.js":"8","/home/xera/web-projects/LOLCODE_Project/src/components/thirdFrame.js":"9","/home/xera/web-projects/LOLCODE_Project/src/components/fifthFrame.js":"10","/home/xera/web-projects/LOLCODE_Project/src/components/secondFrame.js":"11","/home/xera/web-projects/LOLCODE_Project/src/components/index.js":"12"},{"size":505,"mtime":1609384691270,"results":"13","hashOfConfig":"14"},{"size":40762,"mtime":1609398220880,"results":"15","hashOfConfig":"14"},{"size":3820,"mtime":1609386699850,"results":"16","hashOfConfig":"14"},{"size":72914,"mtime":1609383850720,"results":"17","hashOfConfig":"14"},{"size":1750,"mtime":1609389904120,"results":"18","hashOfConfig":"14"},{"size":362,"mtime":1609384707470,"results":"19","hashOfConfig":"14"},{"size":1811,"mtime":1609395057110,"results":"20","hashOfConfig":"14"},{"size":573,"mtime":1609396098480,"results":"21","hashOfConfig":"14"},{"size":1907,"mtime":1609398233550,"results":"22","hashOfConfig":"14"},{"size":1994,"mtime":1609398831260,"results":"23","hashOfConfig":"14"},{"size":2565,"mtime":1609398831260,"results":"24","hashOfConfig":"14"},{"size":151,"mtime":1609385553550,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"mwyusg",{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"31","messages":"32","errorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36","usedDeprecatedRules":"28"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"28"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"46","usedDeprecatedRules":"28"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/home/xera/web-projects/LOLCODE_Project/src/index.js",[],["55","56"],"/home/xera/web-projects/LOLCODE_Project/src/utils/semantics.js",["57"],"/home/xera/web-projects/LOLCODE_Project/src/utils/lexemes.js",["58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75"],"export const keywords = \n    {\n        \"HAI\":['Start','Code Delimiter Keyword'],\n        \"KTHXBYE\":['End','Code Delimiter Keyword'],\n        \"BTW\":['Comment','Line Comment Keyword'],\n        \"OBTW\":['Multi-Line Comment Start','Comment Delimiter Keyword'],\n        \"TLDR\":['Multi-Line Comment End','Comment Delimiter Keyword'],\n        \"I HAS A\":['Declare Var','Variable Declaration Keyword'],\n        \"ITZ\":['Initialize Var','Variable Initialization Keyword'],\n        \"R\":['Assigment Var','Variable Assignment Keyword'],\n        \"SUM OF\":['Arithmetic','Addition Operation Keyword'],\n        \"DIFF OF\":['Arithmetic','Subtraction Operation Keyword'],\n        \"PRODUKT OF\":['Arithmetic','Multiplication Operation Keyword'],\n        \"QUOSHUNT OF\":['Arithmetic','Division Operation Keyword'],\n        \"MOD OF\":['Arithmetic','Modulo Operation Keyword'],\n        \"BIGGR OF\":['Arithmetic','Max Operation Keyword'],\n        \"SMALLR OF\":['Arithmetic','Min Operation Keyword'],\n        \"BOTH OF\":['Boolean','AND Operation Keyword'],\n        \"EITHER OF\":['Boolean','OR Operation Keyword'],\n        \"WON OF\":['Boolean','XOR Operation Keyword'],\n        \"NOT\":['Boolean','NOT Operation Keyword'],\n        \"ANY OF\":['Boolean Many','OR Delimiter Operation Keyword'],\n        \"ALL OF\":['Boolean Many','AND Delimiter Operation Keyword'],\n        \"BOTH SAEM\":['Comparison','Equal Operation Keyword'],\n        \"DIFFRINT\":['Comparison','Not Equal Operation Keyword'],\n        \"SMOOSH\":['Concat','Concatenation Operation Keyword'],\n        \"MAEK\":['Declare Typecast','Type Casting Declaration Keyword'],\n        \"IS NOW\":['Initialize Typecast','Type Casting Initialization Keyword'],\n        \"A\":['Type Keyword','Type Keyword'],\n        \"VISIBLE\":['Output','Output Keyword'],\n        \"GIMMEH\":['Input','Input Keyword'],\n        \"O RLY\":['If-Else','If-Else Delimiter Keyword'],\n        \"YA RLY\":['If','If Keyword'],\n        \"MEBBE\":['Else-If','Else-If Keyword'],\n        \"NO WAI\":['Else','Else Keyword'],\n        \"OIC\":['Flow-Control End','Flow-Control Delimiter Keyword'],\n        \"WTF\":['Switch','Switch Case Delimiter Keyword'],\n        \"OMG\":['Switch Option','Case Keyword'],\n        \"OMGWTF\":['Switch Default','Case-Default Keyword'],\n        \"GTFO\":['Break','Break Keyword'],\n        \"IM IN\":['Loop','Loop Delimiter Keyword'],\n        \"YR\":['Delimiter','Parameter Delimiter Keyword'],\n        \"UPPIN\":['Loop Inc','Increment Keyword'],\n        \"NERFIN\":['Loop Dec','Decrement Keyword'],\n        \"TIL\":['Loop Cond','Loop Keyword'],\n        \"WILE\":['Loop Cond','Loop Keyword'],\n        \"IM OUTTA\":['Loop End','Loop Delimiter Keyword'],\n        \"AN\":['Conjunction','Operand Delimiter Keyword'],\n        \"HOW IZ I\":['Function', 'Function Delimeter Keyword'],\n        \"IF U SAY SO\":['Function End', 'Function Delimeter Keyword'],\n        \"FOUND\": ['Function Return','Function Return Keyword'],\n        \"I IZ\":['Function Call', 'Function Call Keyword'],\n        \"NUMBR\":['Type','NUMBR Type Keyword'],\n        \"NUMBAR\":['Type','NUMBAR Type Keyword'],\n        \"YARN\":['Type','YARN Type Keyword'],\n        \"TROOF\":['Type','TROOF Type Keyword'],\n        \"MKAY\":['Boolean Many','Infinite Delimiter Keyword'],\n    }\n\n\nexport const literal = {\n    \"NUMBR\":[/(^\\-?[0-9]+$)/,'NUMBR Literal'],\n    \"NUMBAR\":[/(^\\-?[0-9]*\\.[0-9]+$)/,'NUMBAR Literal'],\n    \"YARN1\":[/(^[\\\"]([^\\\"]|(\\:\\\"))*$)/,'YARN Literal'],\n    \"YARN2\":[/(^([^\\\"]|(\\:\\\"))*[\\\"][\\!\\,]{0,2}$)/,'YARN Literal'],\n    \"YARN\":[/(^[\\\"]([^\\\"]|(\\:\\\"))*[\\\"]$)/,'YARN Literal'],\n    \"TROOF\":[/^((WIN)|(FAIL))$/,'TROOF Literal'],\n}\n\nexport const identifier = [/^([A-Za-z]+[0-9\\_]*)$/,'Identifier']\n\nexport const types = {\n    \"NUMBR\":['Type','NUMBR Type'],\n    \"NUMBAR\":['Type','NUMBAR Type'],\n    \"YARN\":['Type','YARN Type'],\n    \"TROOF\":['Type','TROOF Type'],\n    \"NOOB\" : ['Type','NOOB Type'],\n}\n\n","/home/xera/web-projects/LOLCODE_Project/src/utils/parser.js",["76","77","78","79","80","81","82","83","84","85","86","87","88","89"],"import { keywords , literal ,identifier, types} from './lexemes';\n\n// inline comment abstraction //okay\nconst inline_comment_abs = (code, tableOfLexemes,lineNumber)=>{\n    code[0] = code[0].join(\" \").trim().split(\" \");\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    // if there is comment after BTW\n    if(code[0].length !== 0){\n        placeholder = code[0].join(\" \");\n        tableOfLexemes.push({value:placeholder,description:'Comment'});\n        code[0] = [];\n    }\n    return [code, tableOfLexemes, lineNumber];\n}\n\n// multiline comment abstraction //okay\nconst multiline_comment_abs = (code, tableOfLexemes, lineNumber) =>{\n    let placeholder = code[0].shift(),error,indexTLDR;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    // getting all the comment before the line of TLDR\n    while(!code[0].includes('TLDR')){\n        placeholder = code.shift().join(\" \").trim();\n        if(placeholder !== \"\"){\n            tableOfLexemes.push({value:placeholder,description:'Comment'});\n        }\n        tableOfLexemes.push({value:'\\n',description:'Line Break'});\n        // if there is no TLDR present in the code\n        if(code.length === 0) return `Syntax Error in line ${lineNumber}: Expected end of Multi-Line Comment.`;\n        code[0]=code[0].trim().split(\" \");\n        error = tokenizer_abs(code,lineNumber);\n        if(!Array.isArray(error)) return error;\n        [code, lineNumber] = error;\n        lineNumber++;\n    }\n    indexTLDR = code[0].indexOf(\"TLDR\");\n    // if there is comment before TLDR\n    if(indexTLDR !== 0){\n        placeholder = code[0].slice(0,indexTLDR).join(\" \").trim();\n        tableOfLexemes.push({value:placeholder,description:'Comment'});\n    }\n    tableOfLexemes.push({value:'TLDR',description:keywords['TLDR'][1]});\n    code[0] = code[0].slice(indexTLDR+1,code[0].length).join(\" \").trim().split(\" \");\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }if(code[0][0] === '' && code[0].length ===1){\n        code[0].shift();\n    }\n    return [code, tableOfLexemes, lineNumber];\n}\n\n// literal abstraction //okay\nconst literal_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),isChanged = true;\n    if(literal[\"NUMBAR\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"NUMBAR\"][1]});\n    }else if(literal[\"NUMBR\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"NUMBR\"][1]});\n    }else if(literal[\"YARN\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"YARN\"][1]});\n    }else if(literal[\"TROOF\"][0].test(placeholder)){\n        tableOfLexemes.push({value:placeholder, description: literal[\"TROOF\"][1]});\n    }else{\n        code[0].unshift(placeholder);\n        isChanged = false;\n    }\n    // if command line break encountered\n    if(isChanged && code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged];\n}\n\n// identifier abstraction //okay\nconst identifier_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    if(placeholder[0] === '\\'' &&  placeholder[placeholder.length-1] === '\\''){\n        // if there are string that were enclose by single quotes\n        return `Syntax Error in line ${lineNumber}: Unexpected Sequence: ${placeholder}.`;\n    }else if(keywords[placeholder] || [\"WIN\",\"FAIL\"].includes(placeholder) || !identifier[0].test(placeholder)){\n        // invalid format of the identifier\n        return `Syntax Error in line ${lineNumber}: Expected Identifier: ${placeholder}.`;\n    }else{\n        tableOfLexemes.push({value:placeholder, description: identifier[1]});\n    }\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// operands abstraction //okay\nconst operands_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let error,isChanged;\n    // literal\n    [code,tableOfLexemes, lineNumber, isChanged] = literal_abs(code,tableOfLexemes,lineNumber);\n    // expression\n    if(!isChanged){\n        error = expression_abs(code,tableOfLexemes,lineNumber,type);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber, isChanged] = error;\n    }\n    // identifier\n    if(!isChanged){\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// output abstraction //okay\nconst output_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift() , error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(tableOfLexemes[tableOfLexemes.length-1].value === \"VISIBLE\" && (code[0].join(\" \").trim().split(\" \")[0] === \",\" ||code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || code[0].length === 0)){\n            // missing operands after the VISIBLE KEYWORD\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }else if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || code[0].length === 0 || tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }else if(code[0].join(\" \").trim().split(\" \")[0] === \"!\"){\n            // no new line encountered\n            code[0] = code[0].join(\" \").trim().split(\" \");\n            tableOfLexemes.push({value:code[0].shift(),description:\"No newline output\"});\n            continue;\n        }else if(tableOfLexemes[tableOfLexemes.length-1].value === \"!\" && code.length !== 0){\n            // if there is operation after ! beside inline comment\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// input abstraction //optimized\nconst input_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the GIMMEH KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    const error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable initialization //optimized\nconst initialization_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the ITZ KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(code[0][0] === \"A\" ){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable declaration //okay\nconst declaration_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        // missing operands after the I HAS A KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error   \n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\" ?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Variable Identifier\";\n    // if special IT identifier\n    if(tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\" ?tableOfLexemes.length-2:tableOfLexemes.length-1].value === \"IT\"){\n        return `Syntax Error in line ${lineNumber}: ${tableOfLexemes.pop().value} is a Special Identifier.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\" && code[0][0] === \"ITZ\"){\n        // initialization\n        error = initialization_var_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// variable assignment //okay\nconst assignment_var_abs = (code,tableOfLexemes,lineNumber)=>{\n    let placeholder;\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }else if(code[0][0] === \"R\"){\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});  \n    }else{\n        // if inproper use of R\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    if(code[0].length === 0){\n        // missing operands after the R KEYWORD\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(code[0][0] === \"MAEK\"){\n        //operands\n        error = typecast_expr_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// arithmetic recursion //okay\nconst arithmetic_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i,error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    for (i = 0; i < 3; i++){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if(i !== 1){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            // if inproper use of AN\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// boolean operations op abstraction  //okay\nconst boolean_operands_abs = (code, tableOfLexemes, lineNumber, type) => {\n    let error, isChanged = true;\n    if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Boolean\"){\n        // boolean operations\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = boolean_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(code[0][0] === \"NOT\"){\n        // not operations\n        error = boolean_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(type && code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Boolean Many\"){\n        // boolean many operations\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = boolean_many_recurse_abs(code,tableOfLexemes,lineNumber);\n    }else if(keywords[code[0][0]] && keywords[code[0][0]][0] === 'Comparison'){\n        // comparison different\n        error = comparison_abs(code,tableOfLexemes,lineNumber);\n    }else if(code[0][1]===\"SAEM\" && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Comparison\")){\n        // comparison same\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = comparison_abs(code,tableOfLexemes,lineNumber);\n    }else{\n        isChanged = false;\n    }\n    if(isChanged){\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged];\n}\n\n// boolean recursion abstraction //optimized\nconst boolean_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i,error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(tableOfLexemes[tableOfLexemes.length - 1].value === \"NOT\"){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        //operands\n        error = operands_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        for (i = 0; i < 3; i++){\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            if(i !== 1){\n                //operands\n                error = operands_abs(code,tableOfLexemes,lineNumber, true);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            }else{\n                // if inproper use of AN\n                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n            }\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// boolean many recursion abstraction //okay\nconst boolean_many_recurse_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error,cnt=0;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(code[0].length === 0 && [\"ANY OF\",\"AN\",\"ALL OF\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(cnt>=2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n            return `Syntax Error in line ${lineNumber}: Expecting MKAY after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if([\"ANY OF\",\"AN\",\"ALL OF\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            cnt ++;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else if(cnt>=2 && code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n            break;\n        }else{\n            if(cnt < 2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// comparison abstraction //okay\nconst comparison_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),i, error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    for (i = 0; i < 3; i++){\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if(i !== 1){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            // if inproper use of AN\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// expression abstraction //okay\nconst expression_abs = (code, tableOfLexemes, lineNumber, type) => {\n    let error,isChanged = true;\n    if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Arithmetic\")){\n        // arithmetic\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = arithmetic_recurse_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else if(type && keywords[code[0][0]] && keywords[code[0][0]][0] === 'Concat'){\n        // concat\n        error = concat_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Function Call\")){\n        // function call\n        code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n        error = function_call_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        // boolean operations\n        error = boolean_operands_abs(code,tableOfLexemes,lineNumber,type);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber,isChanged] = error;\n    }\n    return [code,tableOfLexemes, lineNumber,isChanged]\n}\n\n// concatenation abstraction //okay\nconst concat_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error,cnt = 0;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    while(true){\n        if(code[0].length === 0 && [\"AN\",\"SMOOSH\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            // lacking operand after AN\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(cnt>=2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n            break;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        if([\"AN\",\"SMOOSH\"].includes(tableOfLexemes[tableOfLexemes.length-1].value)){\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            cnt++;\n        }else if(code[0][0] === \"AN\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else if(cnt>=2 && code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n            break;\n        }else{\n            if(cnt < 2 && (code[0].length === 0 || code[0].join(\" \").trim().split(\" \")[0] === \"BTW\" || tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\")){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n} \n\n// if else abstraction //okay\nconst if_else_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let placeholder = code[0].shift(), if_active = false,else_active = false,end=false,error;\n    placeholder = placeholder.slice(0,placeholder.length-1);\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    tableOfLexemes.push({value:\"?\",description:'Control Flow Delimiter'});\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of Flow Control.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if (code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"YA RLY\" && !if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = [code[0].shift(),code[0].shift()].join(\" \");\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"MEBBE\" && if_active && !else_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operation after ${placeholder}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;   \n        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"NO WAI\" && if_active && !else_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = [code[0].shift(),code[0].shift()].join(\" \");\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            else_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"OIC\" && if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(if_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            error = statement_abs(code,tableOfLexemes,lineNumber,type);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description) && code[0][0] === 'OBTW'){\n            // multiline comment\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0].length !== 0 && !if_active){\n            // if there is no if\n            return `Syntax Error in line ${lineNumber}: Expected start of Flow Control: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// Switch Case Abstraction //optimized\nconst switch_case_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let placeholder = code[0].shift(),start_active = false,default_active = false,end =false,error,listOfOptions = [],indexConstant=0;\n    placeholder = placeholder.slice(0,placeholder.length-1);\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    tableOfLexemes.push({value:\"?\",description:'Control Flow Delimiter'});\n    // if command line break encountered\n    if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n        code[0] = code[0].join(\" \").trim().split(\" \");\n        tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n    }\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of Flow Control.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if(code[0][0] === \"OMG\" && !default_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operation after ${placeholder}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            indexConstant = tableOfLexemes.length;\n            //operands\n            error = operands_abs(code,tableOfLexemes,lineNumber, true);\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            if(!tableOfLexemes[indexConstant].description.split(\" \").includes(\"Literal\")){\n                return `Syntax Error in line ${lineNumber}: Expected Constant Value at ${tableOfLexemes[indexConstant].value}.`;\n            }else if(listOfOptions.includes(tableOfLexemes[indexConstant].value)){\n                return `Syntax Error in line ${lineNumber}: OMG Literal Must be Unique at ${tableOfLexemes[indexConstant].value}.`;\n            }\n            listOfOptions.push(tableOfLexemes[indexConstant].value);\n            start_active = true;   \n        }else if(code[0][0] === \"OMGWTF\" && start_active && !default_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            default_active = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(code[0][0] === \"OIC\" && start_active && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value:code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if((start_active || default_active) && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            error = statement_abs(code,tableOfLexemes,lineNumber,type===\"Function\"? type:\"Block Operations\");\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description) && code[0][0] === 'OBTW'){\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(code[0].length !== 0 && !start_active){\n            return `Syntax Error in line ${lineNumber}: Expected start of Flow Control: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// loop abstraction //okay\nconst loop_abs = (code, tableOfLexemes, lineNumber,type) => {\n    let placeholder = code[0].shift(),error,end=false,loopName='';\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // for the name of the loop with the YR before\n    if(code[0][0] === \"YR\"){\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        // identifier\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n        loopName = tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].value;\n        tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Loop Identifier\";\n        if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0].length === 0){\n            return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n        }\n        if(code[0][0] === \"\"){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }\n        // increment or decrement with the UPPIN and the NERFIN\n        if(code[0][0] === \"UPPIN\" | code[0][0] === \"NERFIN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}es[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            // variable to be incremented with YR before\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                // identifier\n                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n                tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Parameter Identifier\";\n                if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                    return `Syntax Error in line ${lineNumber}: Invalid Operation: ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                // the conditionals in the loop\n                if(code[0][0] === \"TIL\" | code[0][0] === \"WILE\"){\n                    placeholder = code[0].shift();\n                    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                    if(code[0].length === 0){\n                        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                    }\n                    if(code[0][0] === \"\"){\n                        // if there is exceeding whitespace in between the operation\n                        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                    }\n                    // the condition\n                    //operands\n                    error = operands_abs(code,tableOfLexemes,lineNumber, true);\n                    // check if error\n                    if(!Array.isArray(error)) return error;\n                    [code,tableOfLexemes, lineNumber] = error;\n                    // body of the loop\n                    while(!end){\n                        if(code.length === 0){\n                            return `Syntax Error in line ${lineNumber-1}: Expected End of the Loop.`;\n                        }\n                        if(code[0].length === 0){\n                            // encounter new line\n                            code.shift();\n                            if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n                            }\n                            lineNumber++;\n                            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n                            if(code.length !== 0){\n                                code[0]=code[0].trim().split(\" \");\n                                if(code[0][0] === ''){\n                                    code[0].shift();\n                                    continue;\n                                }\n                                error = tokenizer_abs(code,lineNumber);\n                                if(!Array.isArray(error)) return error;\n                                [code, lineNumber] = error;\n                            }\n                            continue;\n                        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IM OUTTA\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n                            // loop code delimiter\n                            placeholder = [code[0].shift(),code[0].shift()].join(' ');\n                            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                            if(code[0].length === 0){\n                                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                            }\n                            if(code[0][0] === \"\"){\n                                // if there is exceeding whitespace in between the operation\n                                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                            }\n                            // name of the loop after the YR\n                            if(code[0][0] === \"YR\"){\n                                placeholder = code[0].shift();\n                                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                                if(code[0].length === 0){\n                                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                                }\n                                if(code[0][0] === \"\"){\n                                    // if there is exceeding whitespace in between the operation\n                                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                                }\n                                // identifier\n                                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                                // check if error\n                                if(!Array.isArray(error)) return error;\n                                [code,tableOfLexemes, lineNumber] = error;\n                                if (loopName !== tableOfLexemes[tableOfLexemes.length-1].value){\n                                    return `Syntax Error in line ${lineNumber}: Mismatched Loop Label.`;\n                                }\n                            }else{\n                                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n                            }\n                            end = true\n                        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n                            // body of the loop\n                            error = statement_abs(code,tableOfLexemes,lineNumber,type===\"Function\"? type:\"Block Operations\");\n                            if(!Array.isArray(error)) return error;\n                            [code,tableOfLexemes, lineNumber] = error;\n                        }\n                        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n                            // inline comment\n                            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n                        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n                            // if there is operation after the identifier\n                            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n                        }\n                    }\n                }else{\n                    return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n                }\n            }else{\n                return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n            }\n        }else{\n            return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n        }\n    }else{\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// function  abstraction //okay\nconst function_abs = (code, tableOfLexemes, lineNumber) => {\n    let placeholder = code[0].shift(),error,end=false;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Function Identifier\";\n    while(true){\n        if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }\n        if(code[0][0] === \"\" && ![\"BTW\",\",\"].includes(code[0].join(\" \").trim().split(\" \")[0])){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }else if(['Operand Delimiter Keyword','Function Identifier'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // identifier\n                error = identifier_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n                tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Parameter Identifier\";\n            }else{\n                if(tableOfLexemes[tableOfLexemes.length-1].value === \"AN\"){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }else{\n                    break;\n                }\n            }\n        }else if(code[0][0] === \"AN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            break;\n        }\n    }\n    // body of the function\n    while(!end){\n        if(code.length === 0){\n            return `Syntax Error in line ${lineNumber-1}: Expected End of the Function.`;\n        }\n        if(code[0].length === 0){\n            // encounter new line\n            code.shift();\n            if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            if(code.length !== 0){\n                code[0]=code[0].trim().split(\" \");\n                if(code[0][0] === ''){\n                    code[0].shift();\n                    continue;\n                }\n                error = tokenizer_abs(code,lineNumber);\n                if(!Array.isArray(error)) return error;\n                [code, lineNumber] = error;\n            }\n            continue;\n        }else if(code[0][3] && [code[0][0],code[0][1],code[0][2],code[0][3]].join(\" \") === \"IF U SAY SO\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // loop code delimiter\n            placeholder = [code[0].shift(),code[0].shift(),code[0].shift(),code[0].shift()].join(' ');\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                code[0].shift()\n                tableOfLexemes.push({value:\",\",description:\"Command Line Break\"});\n            }\n            end = true\n        }else if(['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // body of the loop\n            error = statement_abs(code,tableOfLexemes,lineNumber, 'Function');\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// function call abstraction //okay\nconst function_call_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    // identifier\n    error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    tableOfLexemes[tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"?tableOfLexemes.length-2:tableOfLexemes.length-1].description = \"Function Identifier\";\n    while(true){\n        if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n            break;\n        }\n        if(code[0][0] === \"\" && ![\"BTW\",\",\"].includes(code[0].join(\" \").trim().split(\" \")[0])){\n            // if there is exceeding whitespace in between the operation\n            return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n        }else if(['Operand Delimiter Keyword','Function Identifier'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // operands\n                error = operands_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }else{\n                if(tableOfLexemes[tableOfLexemes.length-1].value === \"AN\"){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }else{\n                    if(code[0][0] === \"MKAY\"){\n                        placeholder = code[0].shift();\n                        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                    }\n                    break;\n                }\n            }\n        }else if(code[0][0] === \"MKAY\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            break;\n        }else if(code[0][0] === \"AN\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n        }else{\n            break;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// statement abstraction //okay\nconst statement_abs = (code,tableOfLexemes,lineNumber,type) => {\n    let error,isChanged = true;\n    let placeholder;\n    [code,tableOfLexemes, lineNumber, isChanged] = literal_abs(code,tableOfLexemes,lineNumber);\n    if(!isChanged){\n        error = expression_abs(code,tableOfLexemes,lineNumber, true);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber, isChanged] = error;\n    }\n    if(!isChanged){\n        isChanged = true;\n        if(code[0][0] === \"BTW\"){\n            error = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"OBTW\"){\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"VISIBLE\"){\n            error = output_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"GIMMEH\"){\n            error = input_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][1] && code[0][2] && keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")] && (keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")][0] === \"Declare Var\")){\n            code[0].unshift([code[0].shift(),code[0].shift(),code[0].shift()].join(\" \"));\n            error = declaration_var_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].includes(\"R\")){\n            error = assignment_var_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][1] && keywords[[code[0][0],code[0][1].slice(0,code[0][1].length-1)].join(\" \")] && (keywords[[code[0][0],code[0][1].slice(0,code[0][1].length-1)].join(\" \")][0] === \"If-Else\")){\n            code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n            error = if_else_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][1] && keywords[[code[0][0],code[0][1]].join(\" \")] && (keywords[[code[0][0],code[0][1]].join(\" \")][0] === \"Loop\")){\n            code[0].unshift([code[0].shift(),code[0].shift()].join(\" \"));\n            error = loop_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][2] && keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")] && (keywords[[code[0][0],code[0][1],code[0][2]].join(\" \")][0] === \"Function\")){\n            code[0].unshift([code[0].shift(),code[0].shift(),code[0].shift()].join(\" \"));\n            error = function_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0][0] === \"WTF?\"){\n            error = switch_case_abs(code,tableOfLexemes,lineNumber,type);\n        }else if(code[0][0] === \"MAEK\"){\n            error = typecast_expr_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].join(' ').includes(\"IS NOW\")){\n            error = typecast_var_abs(code,tableOfLexemes,lineNumber);\n        }else if([\"TLDR\",\"OIC\"].includes(code[0][0])){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Flow-Control Structure: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][3] && [code[0][0],code[0][1],code[0][2],code[0][3]].join(\" \") === \"IF U SAY SO\"){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Function Structure: ${code[0].join(\" \").trim()}.`;\n        }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IM OUTTA\"){\n            return `Syntax Error in line ${lineNumber}: Expected Starting Loop Structure: ${code[0].join(\" \").trim()}.`;\n        }else{\n            isChanged = false;\n        }\n        if(isChanged){\n            // check if error\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            if(code.length === 0){\n                return [code,tableOfLexemes, lineNumber];\n            }\n        }\n    }\n    if(!isChanged && (type === \"Function\" || type === \"Block Operations\")){\n        isChanged = true;\n        if(type === \"Function\" && code[0][0] === \"FOUND\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // loop code delimiter\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            if(code[0].length === 0){\n                return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n            }\n            if(code[0][0] === \"\"){\n                // if there is exceeding whitespace in between the operation\n                return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n            }\n            if(code[0][0] === \"YR\"){\n                placeholder = code[0].shift();\n                tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n                if(code[0].length === 0){\n                    return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n                }\n                if(code[0][0] === \"\"){\n                    // if there is exceeding whitespace in between the operation\n                    return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n                }\n                // return value\n                error = operands_abs(code,tableOfLexemes,lineNumber);\n                // check if error\n                if(!Array.isArray(error)) return error;\n                [code,tableOfLexemes, lineNumber] = error;\n            }\n        }else if(code[0][0] === \"GTFO\" && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description)){\n            // break code delimiter\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                code[0].shift()\n                tableOfLexemes.push({value:\",\",description:\"Command Line Break\"});\n            }\n        }else{\n            isChanged = false;\n        }\n    }\n    if(!isChanged){\n        // identifier\n        error = identifier_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;      \n    }\n    if(code[0].length !== 0){\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n        }else if(code[0].length !== 0 && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n            // if there is operation after the identifier\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }\n    }\n    return [code,tableOfLexemes, lineNumber]; \n}\n\n// type casting of expression //okay\nconst typecast_expr_abs = (code, tableOfLexemes, lineNumber) =>{\n    let placeholder = code[0].shift(),error;\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    //operands\n    error = operands_abs(code,tableOfLexemes,lineNumber, true);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    // typecasting to data type\n    if(code[0][0] === \"A\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n    }else{\n        return `Syntax Error in line ${lineNumber}: Missing Operands ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// type casting of var //okay\nconst typecast_var_abs = (code,tableOfLexemes,lineNumber) => {\n    let placeholder;\n    // identifier\n    let error = identifier_abs(code,tableOfLexemes,lineNumber);\n    // check if error\n    if(!Array.isArray(error)) return error;\n    [code,tableOfLexemes, lineNumber] = error;\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }else if(code[0][1] && [code[0][0],code[0][1]].join(\" \") === \"IS NOW\" && tableOfLexemes[tableOfLexemes.length-1].description !== \"Command Line Break\"){\n        placeholder = [code[0].shift(),code[0].shift()].join(' ');\n        tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});  \n    }else{\n        // if inproper use of IS NOW\n        return `Syntax Error in line ${lineNumber}: Invalid Operation: ${code[0][0]}.`;\n    }\n    // typecasting to data type\n    if(code[0][0] === \"A\" ){\n        //type init\n        error = type_init_abs(code,tableOfLexemes,lineNumber);\n        // check if error\n        if(!Array.isArray(error)) return error;\n        [code,tableOfLexemes, lineNumber] = error;\n\n    }else{\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length - 1].value}.`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// type initialization abstraction //okay\nconst type_init_abs = (code, tableOfLexemes,lineNumber) => {\n    let placeholder = code[0].shift();\n    tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n    if(code[0].length === 0){\n        return `Syntax Error in line ${lineNumber}: Missing Operands after ${tableOfLexemes[tableOfLexemes.length-1].value}.`;\n    }\n    if(code[0][0] === \"\"){\n        // if there is exceeding whitespace in between the operation\n        return `Syntax Error in line ${lineNumber}: Exceeding whitespace.`;\n    }\n    if(types[code[0][0]]){\n        // data types\n        placeholder = code[0].shift();\n        tableOfLexemes.push({value:placeholder,description:types[placeholder][1]});\n        // if command line break encountered\n        if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n            code[0] = code[0].join(\" \").trim().split(\" \");\n            tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n        }\n    }else{\n        return `Syntax Error in line ${lineNumber}: Expected Data Type`;\n    }\n    return [code,tableOfLexemes, lineNumber];\n}\n\n// yarn tokenizer and joiner abs\nconst tokenizer_abs = (code,lineNumber) => {\n    let index1,index2,tempHolder = [];\n    while(true){\n        index1 = code[0].findIndex((word)=>literal[\"YARN1\"][0].test(word));\n        if(index1 === -1) break;\n        index2 = code[0].findIndex((word,index)=>(literal[\"YARN2\"][0].test(word) && index !== index1));\n        if(index2>-1){\n            code[0][index1] = code[0].slice(index1,index2+1).join(\" \");\n            code[0] = code[0].slice(0,index1+1).concat(code[0].slice(index2+1,code[0].length));\n        }else{\n            // if lacking closing \"\n            return `Syntax Error in line ${lineNumber}: Unexpected Sequence: ${code[0].slice(index1,code[0].length).join(\" \").trim()}.`;\n        }\n    }\n    code[0].map((item)=>{\n        if(item[0] === '\\\"' && item[item.length-1] === '\\\"'){\n            tempHolder.push(item);\n        }else{\n            let temp_array = item.replace(/[\\,]/g, \" \\,\").replace(/[\\!]/g, \" \\!\").trim().replace(/[\\!](?=[^\\ ])/g, \"\\! \").replace(/[\\,](?=[^\\ ])/g, \"\\, \").trim().split(\" \");\n            if(item[0] === '\\\"'){\n                const index1 = temp_array.findIndex((word)=>literal[\"YARN1\"][0].test(word));\n                if(index1 !== -1){\n                    const index2 = temp_array.findIndex((word,index)=>(literal[\"YARN2\"][0].test(word) && index !== index1));\n                    if(index1 !== -1){\n                        temp_array[index1] = temp_array.slice(index1,index2+1).join(\" \");\n                        temp_array = temp_array.slice(0,index1+1).concat(temp_array.slice(index2+1,temp_array.length));\n                    }\n                }\n            }\n            tempHolder.push(...temp_array);\n        }\n        return item;\n      })\n    code[0] = tempHolder;\n    return [code,lineNumber];\n}\n\n// start program \nexport const program_abs = (code,tableOfLexemes,lineNumber) =>{\n    let start = false, end = false,placeholder,error;\n    code = code.split(\"\\n\");\n    while(code.length !==0){\n        if(!Array.isArray(code[0])){\n            // new line of code encountered\n            code[0] = code[0].trim().split(\" \");\n            // when there is no content in the line\n            if(code[0][0] === ''){\n                code[0].shift();\n                continue;\n            }\n            //tokenizer\n            error = tokenizer_abs(code,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code, lineNumber] = error;\n            continue;\n        }else if(code[0].length === 0){\n            // if new line encountered\n            code.shift();\n            if(tableOfLexemes[tableOfLexemes.length-1].description === \"Command Line Break\"){\n                return `Syntax Error in line ${lineNumber}: Expected Statement after: ${tableOfLexemes[tableOfLexemes.length-1].value}.`; \n            }\n            lineNumber++;\n            tableOfLexemes.push({value:'\\n',description:'Line Break'});\n            continue;\n        }\n        if(code[0].join(\" \").trim().split(\" \")[0] === \"BTW\"){\n            // inline comment\n            [code,tableOfLexemes, lineNumber] = inline_comment_abs(code,tableOfLexemes,lineNumber);\n            continue;\n        }else if((!start || (end && ['Line Break','Command Line Break'].includes(tableOfLexemes[tableOfLexemes.length-1].description))) && code[0][0] === 'OBTW'){\n            // multiline comment\n            error = multiline_comment_abs(code,tableOfLexemes,lineNumber);\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n            continue;\n        }\n        if(!start && code[0][0] === \"HAI\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            start = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(start && !end && code[0][0] === \"KTHXBYE\"){\n            placeholder = code[0].shift();\n            tableOfLexemes.push({value:placeholder,description:keywords[placeholder][1]});\n            end = true;\n            // if command line break encountered\n            if(code[0].join(\" \").trim().split(\" \")[0] === \",\"){\n                code[0] = code[0].join(\" \").trim().split(\" \");\n                tableOfLexemes.push({value: code[0].shift(),description:\"Command Line Break\"});\n            }\n        }else if(start && !end){\n            // main body of the program\n            error = statement_abs(code,tableOfLexemes,lineNumber,'None');\n            if(!Array.isArray(error)) return error;\n            [code,tableOfLexemes, lineNumber] = error;\n        }else if(start && code[0].length !== 0){\n            return `Syntax Error in line ${lineNumber}: Expected end of Expression: ${code[0].join(\" \").trim()}.`;\n        }else{\n            return `Syntax Error in line ${lineNumber}: Expected start of the program.`;\n        }\n    }\n    if(!end && start){\n        return `Syntax Error in line ${lineNumber}: Expected end of the program.`;\n    }\n    return [code,tableOfLexemes, lineNumber]; \n}","/home/xera/web-projects/LOLCODE_Project/src/main/App.js",[],"/home/xera/web-projects/LOLCODE_Project/src/reportWebVitals.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/firstFrame.js",["90"],"import React, { useState,useRef,useEffect } from 'react';\nimport { Upload } from 'antd';\nimport AceEditor from 'react-ace';\nimport 'antd/dist/antd.css';\nimport '../main/App.css';\nimport \"ace-builds/src-noconflict/theme-github\";\n\nexport const FirstFrame = ({ lolText, setLolText,buttonClickCount }) => {\n  // Dragger is the file uploader above\n  const isInitialMountFirstFrame = useRef(true);\n  const [localLolText,setLocalLolText] = useState(lolText);\n  const { Dragger } = Upload;\n  const [files, setfiles] = useState([]);\n  const [fileProperty] = useState(\n    {\n      name: 'file',\n      multiple: false,\n      accept : \".lol\",\n      beforeUpload(file){\n        readFile(file);\n        return false;\n      },\n      onChange(info){\n        handleChange(info);\n      }\n    }\n  );\n\n// This Part handle changes in the file (i.e if a file is added)\nconst handleChange = (info) => {\n  setfiles([...info.fileList].slice(-1));\n}\n\n// This part catches the file that is uploaded/dragged to the Upload field\nconst readFile = async(file) => {\n    setLocalLolText(await file.text());\n}\n\n// If the button is clicked we set the main lol text which signals the second frame to parse the data\nuseEffect(() => {\n  if(isInitialMountFirstFrame.current){\n    isInitialMountFirstFrame.current = false\n  }else{\n    setLolText(localLolText)\n  }\n},[buttonClickCount])\n\n  return (\n    <div className=\"firstFrame\">\n        <Dragger className=\"dragBox\" {...fileProperty} fileList = {files} showUploadList={false}>\n          <p style={{color:'white'}}>Drag Your LOL Code File Here</p>\n        </Dragger>\n        <AceEditor mode={\"null\"} theme={\"github\"} width={\"100%\"} height={\"100%\"} showPrintMargin={false} placeholder={\"BTW Your code goes here\"} value = {localLolText} onChange ={(value)=>{setLocalLolText(value)}}/>\n    </div>\n  )\n}\n","/home/xera/web-projects/LOLCODE_Project/src/components/fourthFrame.js",["91"],"import React, { useState } from 'react';\nimport { Button } from 'antd';\nimport '../main/App.css';\n\nexport const FourthFrame = (props) => {\n\n  const handleOnClick = (event) => {\n    // props.setParsedLol([])\n    // props.setSymbolTable([])\n    console.log(\"BUTTON CLICKED\")\n    props.setButtonClickCount(props.buttonClickCount+1)\n    console.log(props.buttonClickCount)\n  }\n\n  console.log(\"FOURTH FRAME HERE\")\n\n  return(\n    <div className=\"fourthFrame\">\n        <Button className=\"executeButton\" type=\"primary\" onClick = {handleOnClick}> Execute </Button>\n    </div>\n  )\n}\n","/home/xera/web-projects/LOLCODE_Project/src/components/thirdFrame.js",[],"/home/xera/web-projects/LOLCODE_Project/src/components/fifthFrame.js",["92","93"],"/home/xera/web-projects/LOLCODE_Project/src/components/secondFrame.js",["94"],"/home/xera/web-projects/LOLCODE_Project/src/components/index.js",[],{"ruleId":"95","replacedBy":"96"},{"ruleId":"97","replacedBy":"98"},{"ruleId":"99","severity":1,"message":"100","line":824,"column":6,"nodeType":"101","messageId":"102","endLine":824,"endColumn":11},{"ruleId":"103","severity":1,"message":"104","line":62,"column":17,"nodeType":"105","messageId":"106","endLine":62,"endColumn":18,"suggestions":"107"},{"ruleId":"103","severity":1,"message":"104","line":63,"column":18,"nodeType":"105","messageId":"106","endLine":63,"endColumn":19,"suggestions":"108"},{"ruleId":"103","severity":1,"message":"109","line":64,"column":18,"nodeType":"105","messageId":"106","endLine":64,"endColumn":19,"suggestions":"110"},{"ruleId":"103","severity":1,"message":"109","line":64,"column":24,"nodeType":"105","messageId":"106","endLine":64,"endColumn":25,"suggestions":"111"},{"ruleId":"103","severity":1,"message":"112","line":64,"column":29,"nodeType":"105","messageId":"106","endLine":64,"endColumn":30,"suggestions":"113"},{"ruleId":"103","severity":1,"message":"109","line":64,"column":31,"nodeType":"105","messageId":"106","endLine":64,"endColumn":32,"suggestions":"114"},{"ruleId":"103","severity":1,"message":"109","line":65,"column":20,"nodeType":"105","messageId":"106","endLine":65,"endColumn":21,"suggestions":"115"},{"ruleId":"103","severity":1,"message":"112","line":65,"column":25,"nodeType":"105","messageId":"106","endLine":65,"endColumn":26,"suggestions":"116"},{"ruleId":"103","severity":1,"message":"109","line":65,"column":27,"nodeType":"105","messageId":"106","endLine":65,"endColumn":28,"suggestions":"117"},{"ruleId":"103","severity":1,"message":"109","line":65,"column":33,"nodeType":"105","messageId":"106","endLine":65,"endColumn":34,"suggestions":"118"},{"ruleId":"103","severity":1,"message":"119","line":65,"column":37,"nodeType":"105","messageId":"106","endLine":65,"endColumn":38,"suggestions":"120"},{"ruleId":"103","severity":1,"message":"121","line":65,"column":39,"nodeType":"105","messageId":"106","endLine":65,"endColumn":40,"suggestions":"122"},{"ruleId":"103","severity":1,"message":"109","line":66,"column":17,"nodeType":"105","messageId":"106","endLine":66,"endColumn":18,"suggestions":"123"},{"ruleId":"103","severity":1,"message":"109","line":66,"column":23,"nodeType":"105","messageId":"106","endLine":66,"endColumn":24,"suggestions":"124"},{"ruleId":"103","severity":1,"message":"112","line":66,"column":28,"nodeType":"105","messageId":"106","endLine":66,"endColumn":29,"suggestions":"125"},{"ruleId":"103","severity":1,"message":"109","line":66,"column":30,"nodeType":"105","messageId":"106","endLine":66,"endColumn":31,"suggestions":"126"},{"ruleId":"103","severity":1,"message":"109","line":66,"column":36,"nodeType":"105","messageId":"106","endLine":66,"endColumn":37,"suggestions":"127"},{"ruleId":"103","severity":1,"message":"128","line":70,"column":44,"nodeType":"105","messageId":"106","endLine":70,"endColumn":45,"suggestions":"129"},{"ruleId":"130","severity":1,"message":"131","line":1278,"column":36,"nodeType":"132","messageId":"133","endLine":1278,"endColumn":102},{"ruleId":"103","severity":1,"message":"109","line":1288,"column":25,"nodeType":"105","messageId":"106","endLine":1288,"endColumn":26,"suggestions":"134"},{"ruleId":"103","severity":1,"message":"109","line":1288,"column":57,"nodeType":"105","messageId":"106","endLine":1288,"endColumn":58,"suggestions":"135"},{"ruleId":"103","severity":1,"message":"121","line":1291,"column":45,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":46,"suggestions":"136"},{"ruleId":"103","severity":1,"message":"121","line":1291,"column":54,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":55,"suggestions":"137"},{"ruleId":"103","severity":1,"message":"119","line":1291,"column":69,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":70,"suggestions":"138"},{"ruleId":"103","severity":1,"message":"119","line":1291,"column":78,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":79,"suggestions":"139"},{"ruleId":"103","severity":1,"message":"119","line":1291,"column":100,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":101,"suggestions":"140"},{"ruleId":"103","severity":1,"message":"141","line":1291,"column":108,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":109,"suggestions":"142"},{"ruleId":"103","severity":1,"message":"119","line":1291,"column":117,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":118,"suggestions":"143"},{"ruleId":"103","severity":1,"message":"121","line":1291,"column":133,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":134,"suggestions":"144"},{"ruleId":"103","severity":1,"message":"141","line":1291,"column":141,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":142,"suggestions":"145"},{"ruleId":"103","severity":1,"message":"121","line":1291,"column":150,"nodeType":"105","messageId":"106","endLine":1291,"endColumn":151,"suggestions":"146"},{"ruleId":"103","severity":1,"message":"109","line":1292,"column":29,"nodeType":"105","messageId":"106","endLine":1292,"endColumn":30,"suggestions":"147"},{"ruleId":"148","severity":1,"message":"149","line":46,"column":3,"nodeType":"150","endLine":46,"endColumn":21,"suggestions":"151"},{"ruleId":"99","severity":1,"message":"152","line":1,"column":17,"nodeType":"101","messageId":"102","endLine":1,"endColumn":25},{"ruleId":"99","severity":1,"message":"152","line":1,"column":17,"nodeType":"101","messageId":"102","endLine":1,"endColumn":25},{"ruleId":"148","severity":1,"message":"153","line":43,"column":7,"nodeType":"150","endLine":43,"endColumn":24,"suggestions":"154"},{"ruleId":"148","severity":1,"message":"153","line":46,"column":7,"nodeType":"150","endLine":46,"endColumn":22,"suggestions":"155"},"no-native-reassign",["156"],"no-negated-in-lhs",["157"],"no-unused-vars","'error' is defined but never used.","Identifier","unusedVar","no-useless-escape","Unnecessary escape character: \\-.","Literal","unnecessaryEscape",["158","159"],["160","161"],"Unnecessary escape character: \\\".",["162","163"],["164","165"],"Unnecessary escape character: \\:.",["166","167"],["168","169"],["170","171"],["172","173"],["174","175"],["176","177"],"Unnecessary escape character: \\!.",["178","179"],"Unnecessary escape character: \\,.",["180","181"],["182","183"],["184","185"],["186","187"],["188","189"],["190","191"],"Unnecessary escape character: \\_.",["192","193"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'index1'.","ArrowFunctionExpression","unsafeRefs",["194","195"],["196","197"],["198","199"],["200","201"],["202","203"],["204","205"],["206","207"],"Unnecessary escape character: \\ .",["208","209"],["210","211"],["212","213"],["214","215"],["216","217"],["218","219"],"react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'localLolText' and 'setLolText'. Either include them or remove the dependency array. If 'setLolText' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["220"],"'useState' is defined but never used.","React Hook useEffect has a missing dependency: 'props'. Either include it or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.",["221"],["222"],"no-global-assign","no-unsafe-negation",{"messageId":"223","fix":"224","desc":"225"},{"messageId":"226","fix":"227","desc":"228"},{"messageId":"223","fix":"229","desc":"225"},{"messageId":"226","fix":"230","desc":"228"},{"messageId":"223","fix":"231","desc":"225"},{"messageId":"226","fix":"232","desc":"228"},{"messageId":"223","fix":"233","desc":"225"},{"messageId":"226","fix":"234","desc":"228"},{"messageId":"223","fix":"235","desc":"225"},{"messageId":"226","fix":"236","desc":"228"},{"messageId":"223","fix":"237","desc":"225"},{"messageId":"226","fix":"238","desc":"228"},{"messageId":"223","fix":"239","desc":"225"},{"messageId":"226","fix":"240","desc":"228"},{"messageId":"223","fix":"241","desc":"225"},{"messageId":"226","fix":"242","desc":"228"},{"messageId":"223","fix":"243","desc":"225"},{"messageId":"226","fix":"244","desc":"228"},{"messageId":"223","fix":"245","desc":"225"},{"messageId":"226","fix":"246","desc":"228"},{"messageId":"223","fix":"247","desc":"225"},{"messageId":"226","fix":"248","desc":"228"},{"messageId":"223","fix":"249","desc":"225"},{"messageId":"226","fix":"250","desc":"228"},{"messageId":"223","fix":"251","desc":"225"},{"messageId":"226","fix":"252","desc":"228"},{"messageId":"223","fix":"253","desc":"225"},{"messageId":"226","fix":"254","desc":"228"},{"messageId":"223","fix":"255","desc":"225"},{"messageId":"226","fix":"256","desc":"228"},{"messageId":"223","fix":"257","desc":"225"},{"messageId":"226","fix":"258","desc":"228"},{"messageId":"223","fix":"259","desc":"225"},{"messageId":"226","fix":"260","desc":"228"},{"messageId":"223","fix":"261","desc":"225"},{"messageId":"226","fix":"262","desc":"228"},{"messageId":"223","fix":"263","desc":"225"},{"messageId":"226","fix":"264","desc":"228"},{"messageId":"223","fix":"265","desc":"225"},{"messageId":"226","fix":"266","desc":"228"},{"messageId":"223","fix":"267","desc":"225"},{"messageId":"226","fix":"268","desc":"228"},{"messageId":"223","fix":"269","desc":"225"},{"messageId":"226","fix":"270","desc":"228"},{"messageId":"223","fix":"271","desc":"225"},{"messageId":"226","fix":"272","desc":"228"},{"messageId":"223","fix":"273","desc":"225"},{"messageId":"226","fix":"274","desc":"228"},{"messageId":"223","fix":"275","desc":"225"},{"messageId":"226","fix":"276","desc":"228"},{"messageId":"223","fix":"277","desc":"225"},{"messageId":"226","fix":"278","desc":"228"},{"messageId":"223","fix":"279","desc":"225"},{"messageId":"226","fix":"280","desc":"228"},{"messageId":"223","fix":"281","desc":"225"},{"messageId":"226","fix":"282","desc":"228"},{"messageId":"223","fix":"283","desc":"225"},{"messageId":"226","fix":"284","desc":"228"},{"messageId":"223","fix":"285","desc":"225"},{"messageId":"226","fix":"286","desc":"228"},{"messageId":"223","fix":"287","desc":"225"},{"messageId":"226","fix":"288","desc":"228"},{"desc":"289","fix":"290"},{"desc":"291","fix":"292"},{"desc":"293","fix":"294"},"removeEscape",{"range":"295","text":"296"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"297","text":"298"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"299","text":"296"},{"range":"300","text":"298"},{"range":"301","text":"296"},{"range":"302","text":"298"},{"range":"303","text":"296"},{"range":"304","text":"298"},{"range":"305","text":"296"},{"range":"306","text":"298"},{"range":"307","text":"296"},{"range":"308","text":"298"},{"range":"309","text":"296"},{"range":"310","text":"298"},{"range":"311","text":"296"},{"range":"312","text":"298"},{"range":"313","text":"296"},{"range":"314","text":"298"},{"range":"315","text":"296"},{"range":"316","text":"298"},{"range":"317","text":"296"},{"range":"318","text":"298"},{"range":"319","text":"296"},{"range":"320","text":"298"},{"range":"321","text":"296"},{"range":"322","text":"298"},{"range":"323","text":"296"},{"range":"324","text":"298"},{"range":"325","text":"296"},{"range":"326","text":"298"},{"range":"327","text":"296"},{"range":"328","text":"298"},{"range":"329","text":"296"},{"range":"330","text":"298"},{"range":"331","text":"296"},{"range":"332","text":"298"},{"range":"333","text":"296"},{"range":"334","text":"298"},{"range":"335","text":"296"},{"range":"336","text":"298"},{"range":"337","text":"296"},{"range":"338","text":"298"},{"range":"339","text":"296"},{"range":"340","text":"298"},{"range":"341","text":"296"},{"range":"342","text":"298"},{"range":"343","text":"296"},{"range":"344","text":"298"},{"range":"345","text":"296"},{"range":"346","text":"298"},{"range":"347","text":"296"},{"range":"348","text":"298"},{"range":"349","text":"296"},{"range":"350","text":"298"},{"range":"351","text":"296"},{"range":"352","text":"298"},{"range":"353","text":"296"},{"range":"354","text":"298"},{"range":"355","text":"296"},{"range":"356","text":"298"},{"range":"357","text":"296"},{"range":"358","text":"298"},"Update the dependencies array to be: [buttonClickCount, localLolText, setLolText]",{"range":"359","text":"360"},"Update the dependencies array to be: [props, props.parsedLol]",{"range":"361","text":"362"},"Update the dependencies array to be: [props, props.lolText]",{"range":"363","text":"364"},[3230,3231],"",[3230,3230],"\\",[3278,3279],[3278,3278],[3335,3336],[3335,3335],[3341,3342],[3341,3341],[3346,3347],[3346,3346],[3348,3349],[3348,3348],[3393,3394],[3393,3393],[3398,3399],[3398,3398],[3400,3401],[3400,3400],[3406,3407],[3406,3406],[3410,3411],[3410,3410],[3412,3413],[3412,3412],[3457,3458],[3457,3457],[3463,3464],[3463,3463],[3468,3469],[3468,3468],[3470,3471],[3470,3470],[3476,3477],[3476,3476],[3596,3597],[3596,3596],[68446,68447],[68446,68446],[68478,68479],[68478,68478],[68578,68579],[68578,68578],[68587,68588],[68587,68587],[68602,68603],[68602,68602],[68611,68612],[68611,68611],[68633,68634],[68633,68633],[68641,68642],[68641,68641],[68650,68651],[68650,68650],[68666,68667],[68666,68666],[68674,68675],[68674,68674],[68683,68684],[68683,68683],[68736,68737],[68736,68736],[1326,1344],"[buttonClickCount, localLolText, setLolText]",[1746,1763],"[props, props.parsedLol]",[1752,1767],"[props, props.lolText]"]